#!/usr/bin/env perl
#
##########################################################################
# @(#) pfm.pl 2010-04-14 v1.95.3
#
# Name:			pfm
# Version:		1.95.3
# Author:		Rene Uittenbogaard
# Created:		1999-03-14
# Date:			2010-04-14
# Usage:		pfm [ <directory> ] [ -s, --swap <directory> ]
#				    [ -l, --layout <number> ]
#				pfm { -v, --version | -h, --help }
# Requires:		Term::ReadLine::Gnu (preferably)
#				Term::ScreenColor
#				Getopt::Long
#				POSIX
#				Config
#				Cwd
#				locale
#				strict
# Description:	Personal File Manager for Unix/Linux
#

##########################################################################
# main data structures:
#
# @dircontents   : array (current directory data) of references (to file data)
# $dircontents[$index]      : reference to hash (=file data)
# $dircontents[$index]{name}
#					  {selected}
#					  {size}
#					  {type}
#
# %currentfile = %{ $dircontents[$currentline+$baseindex] } (current file data)
# $currentfile{name}
#			  {selected}
#			  {size}
#			  {type}

##########################################################################
# requirements
#
#require 5.006;
#
#use Term::ScreenColor;
#use Term::ReadLine;
#use Getopt::Long;
use POSIX qw(strftime mktime);
#use Config;
#use Cwd;
use locale;
#use strict;
#use warnings;
#use diagnostics;
#disable diagnostics; # so we can switch it on in '@'
#$^W = 0;

our($FALSE,
	$TRUE,
#	$READ_FIRST,
#	$READ_AGAIN,
	$QUOTE_OFF,
	$QUOTE_ON,
#	$MOUSE_OFF,
#	$MOUSE_ON,
#	$ALTERNATE_OFF,
#	$ALTERNATE_ON,
#	$TERM_RAW,
#	$TERM_COOKED,
#	$FILENAME_SHORT,
#	$FILENAME_LONG,
#	$HIGHLIGHT_OFF,
#	$HIGHLIGHT_ON,
#	$TIME_FILE,
#	$TIME_CLOCK,
#	$HEADER_SINGLE,
#	$HEADER_MULTI,
#	$HEADER_MORE,
#	$HEADER_SORT,
#	$HEADER_INCLUDE,
#	$HEADER_LNKTYPE,
#	$HEADING_DISKINFO,
#	$HEADING_YCOMMAND,
#	$HEADING_SIGNAL,
#	$HEADING_SORT,
#	$HEADING_ESCAPE,
#	$R_NOP,
#	$R_STRIDE,
#	$R_MENU,
#	$R_PATHINFO,
#	$R_HEADINGS,
#	$R_FOOTER,
#	$R_DIRFILTER,
#	$R_DIRLIST,
#	$R_DISKINFO,
#	$R_DIRSORT,
#	$R_CLEAR,
#	$R_DIRCONTENTS,
#	$R_NEWDIR,
#	$R_INIT_SWAP,
#	$R_QUIT,
#);

#END {
#	# in case something goes wrong
#	system qw(stty -raw echo);
#}

##########################################################################
# declarations and initialization

*FALSE			= \0;
*TRUE			= \1;
#*READ_FIRST		= \0;
#*READ_AGAIN		= \1;
*QUOTE_OFF		= \0;
*QUOTE_ON		= \1;
#*MOUSE_OFF		= \0;
#*MOUSE_ON		= \1;
#*ALTERNATE_OFF	= \0;
#*ALTERNATE_ON	= \1;
#*TERM_RAW		= \0;
#*TERM_COOKED	= \1;
#*FILENAME_SHORT	= \0;
#*FILENAME_LONG	= \1;
#*HIGHLIGHT_OFF	= \0;
#*HIGHLIGHT_ON	= \1;
#*TIME_FILE		= \0;
#*TIME_CLOCK		= \1;
#*HEADER_SINGLE	= \0;
#*HEADER_MULTI	= \1;
#*HEADER_MORE	= \2;
#*HEADER_SORT	= \4;
#*HEADER_INCLUDE	= \8;
#*HEADER_LNKTYPE	= \16;
#*HEADING_DISKINFO	= \0;
#*HEADING_YCOMMAND	= \1;
#*HEADING_SIGNAL	= \2;
#*HEADING_SORT		= \3;
#*HEADING_ESCAPE	= \4;
#*R_NOP			= \0;
#*R_STRIDE		= \1;
#*R_MENU		= \2;
#*R_PATHINFO		= \4;
#*R_HEADINGS		= \8;
#*R_FOOTER		= \16;
#*R_DIRFILTER	= \32;
#*R_DIRLIST		= \64;
#*R_DISKINFO		= \128;
#*R_DIRSORT		= \256;
#*R_CLEAR		= \512;
#*R_DIRCONTENTS	= \1024;
#*R_NEWDIR		= \2048;
#*R_INIT_SWAP	= \4096;
#*R_QUIT			= \1048576;
#
#my $R_FRAME		= $R_MENU | $R_PATHINFO | $R_HEADINGS | $R_FOOTER;
#my $R_SCREEN	= $R_DIRFILTER | $R_DIRLIST | $R_DISKINFO | $R_FRAME;
#my $R_CLRSCR	= $R_CLEAR | $R_SCREEN;
#my $R_CHDIR		= $R_NEWDIR | $R_DIRCONTENTS | $R_DIRSORT | $R_SCREEN
#				| $R_STRIDE;
#
#my ($VERSION,$LASTYEAR)	= getversion();
#my $CONFIGDIRNAME		= "$ENV{HOME}/.pfm";
#my $CONFIGFILENAME		= '.pfmrc';
#my $CONFIGDIRMODE		= 0700;
#my $CWDFILENAME			= 'cwd';
#my $SWDFILENAME			= 'swd';
my $LOSTMSG				= '';   # was ' (file lost)'; # now shown through coloring
#my $MAJORMINORSEPARATOR	= ',';
#my $NAMETOOLONGCHAR		= '+';
#my $MAXHISTSIZE			= 70;
#my $ERRORDELAY			= 1;    # in seconds (fractions allowed)
#my $IMPORTANTDELAY		= 2;    # extra time for important errors
#my $SLOWENTRIES			= 300;
#my $PATHLINE			= 1;
#my $BASELINE			= 3;
#my $DISKINFOLINE		= 4;
#my $DIRINFOLINE			= 9;
#my $MARKINFOLINE		= 15;
#my $USERINFOLINE		= 21;
#my $DATEINFOLINE		= 22;
#my $DFCMD				= ($^O eq 'hpux') ? 'bdf' : ($^O eq 'sco') ? 'dfspace' : 'df -k';

#my $XTERMS				= qr/^(.*xterm.*|rxvt.*|gnome|kterm)$/;
#my @SYMBOLIC_MODES		= qw(--- --x -w- -wx r-- r-x rw- rwx);
#my %IDENTMODES			= ( user => 0, host => 1, 'user@host' => 2);
my %NUMFORMATS			= ( 'hex' => '%#04lx', 'oct' => '%03lo');

#my %FILETYPEFLAGS		= (
#	# ls(1)
#	x => '*',
#	d => '/',
#	l => '@',
#	p => '|',
#   's'=> '=',
#	D => '>',
#	w => '%',
#	# tcsh(1)
#	b => '#',
#	c => '%',
#	n => ':',
#	# => '+', # Hidden directory (AIX only) or context dependent (HP/UX only)
#);

my @SORTMODES = (
	 n =>'Name',		N =>' reverse',
	'm'=>' ignorecase',	M =>' rev+igncase',
	 e =>'Extension',	E =>' reverse',
	 f =>' ignorecase',	F =>' rev+igncase',
	 d =>'Date/mtime',	D =>' reverse',
	 a =>'date/Atime',	A =>' reverse',
	's'=>'Size',		S =>' reverse',
	'z'=>'siZe total',	Z =>' reverse',
	 t =>'Type',		T =>' reverse',
	 i =>'Inode',		I =>' reverse',
#	 v =>'sVn',			V =>' reverse',
);

my %CMDESCAPES = (
	'1' => 'name',
	'2' => 'name.ext',
	'3' => 'curr path',
	'4' => 'mountpoint',
	'5' => 'swap path',
	'6' => 'base path',
	'7' => 'extension',
	'8' => 'selection',
	'e' => 'editor',
	'p' => 'pager',
	'v' => 'viewer',
);

## AIX,BSD,Tru64	: du gives blocks, du -k kbytes
## Solaris		: du gives kbytes
## HP			: du gives blocks,               du -b something unwanted
## Linux			: du gives blocks, du -k kbytes, du -b bytes
## Darwin		: du gives blocks, du -k kbytes
## the ${e} is replaced later
#my %DUCMDS = (
#	default	=> q(du -sk ${e}2 | awk '{ printf "%d", 1024 * $1 }'),
#	solaris	=> q(du -s  ${e}2 | awk '{ printf "%d", 1024 * $1 }'),
#	sunos	=> q(du -s  ${e}2 | awk '{ printf "%d", 1024 * $1 }'),
#	hpux	=> q(du -s  ${e}2 | awk '{ printf "%d",  512 * $1 }'),
#	linux	=> q(du -sb ${e}2),
##	aix		=> can use the default
##	freebsd	=> can use the default
##	netbsd	=> can use the default unless proven otherwise
##	dec_osf	=> can use the default unless proven otherwise
##	beos	=> can use the default unless proven otherwise
##	irix	=> can use the default unless proven otherwise
##	sco		=> can use the default unless proven otherwise
##	darwin	=> can use the default
#	# MSWin32, os390 etc. not supported
#);

#my %RDEVTOMAJOR = (
#	default	=> 2 **  8,
#	aix		=> 2 ** 16,
#	irix	=> 2 ** 18,
#	solaris	=> 2 ** 18,
#	sunos	=> 2 ** 18,
#	dec_osf	=> 2 ** 20,
#	tru64	=> 2 ** 20, # correct value for $OSNAME on Tru64?
#	hpux	=> 2 ** 24,
#);

#my %LAYOUTFIELDS = (
#	'*' => 'selected',
#	'n' => 'display',
#	'N' => 'name_too_long',
#	's' => 'size_num',
#	'S' => 'size_power',
#	'z' => 'grand_num',
#	'Z' => 'grand_power',
#	'u' => 'uid',
#	'g' => 'gid',
#	'p' => 'mode',
#	'a' => 'atimestring',
#	'c' => 'ctimestring',
#	'm' => 'mtimestring',
#	'l' => 'nlink',
#	'i' => 'inode',
#	'd' => 'rdev',
#	'v' => 'svn',
#	'f' => 'diskinfo',
#);
#
#my %FIELDHEADINGS = (
#	selected		=> ' ',
#	name			=> 'filename',
#	display			=> 'filename',
#	name_too_long	=> ' ',
#	size			=> 'size',
#	size_num		=> 'size',
#	size_power		=> ' ',
#	grand			=> 'total',
#	grand_num		=> 'total',
#	grand_power		=> ' ',
#	inode			=> 'inode',
#	mode			=> 'perm',
#	atime			=> 'date/atime',
#	mtime			=> 'date/mtime',
#	ctime			=> 'date/ctime',
#	atimestring		=> 'date/atime',
#	mtimestring		=> 'date/mtime',
#	ctimestring		=> 'date/ctime',
#	uid				=> 'userid',
#	gid				=> 'groupid',
#	nlink			=> 'lnks',
#	rdev			=> 'dev',
#	svn				=> 'svn',
#	diskinfo		=> 'disk info',
#);
#
#my $screenheight	= 20;    # inner height
#my $screenwidth		= 80;    # terminal width
#my $position_at		= '.';   # start with cursor here

#my (@command_history, @mode_history, @path_history, @regex_history,
#	@perlcmd_history, @time_history);
#
#my %HISTORIES = (
#	history_command	=> \@command_history,
#	history_mode	=> \@mode_history,
#	history_path	=> \@path_history,
#	history_regex	=> \@regex_history,
#	history_time	=> \@time_history,
#	history_perlcmd	=> \@perlcmd_history
#);
#
#my (
#	# lookup tables
#	%usercache, %groupcache, %pfmrc, @signame, %dircolors, %framecolors,
#	# screen- and keyboard objects, screen parameters
#	$scr, $kbd, $wasresized, $wasquit, $currentpan,
#	# modes
#	$sort_mode, $multiple_mode, $swap_mode, $dot_mode, $dotdot_mode, $white_mode,
#	$mouse_mode, $color_mode, $ident_mode, $radix_mode, $clobber_mode, $path_mode,
#	$altscreen_mode,
#	# dir- and disk info
#	$currentdir, $oldcurrentdir, @dircontents, @showncontents, %currentfile,
#	%disk, $swap_state, %total_nr_of, %selected_nr_of, $ident,
#	# cursor position
#	$currentline, $baseindex, $cursorcol, $filenamecol, $infocol, $filerecordcol,
#	# misc config options
#	$editor, $pager, $viewer, $windowcmd, $printcmd, $ducmd, $chdirautocmd, $e,
#	$autoexitmultiple, $cursorveryvisible, $clsonexit, $rdevtomajor, $trspace,
#	$autowritehistory, $swap_persistent, $mouseturnoff, $showlockchar,
#	@colorsetnames, %filetypeflags, $swapstartdir, $waitlaunchexec,
#	$remove_marks_ok,
#	# layouts and formatting
#	$currentformatline, $currentformatlinewithinfo, $currentlayout, $formatname,
#	@layoutfields, @layoutfieldswithinfo, @columnlayouts,
#	$maxfilenamelength, $maxfilesizelength, $maxgrandtotallength, $infolength,
#	# rcs
#	$rcsbuffer, $rcsrunning, $rcs_need_refresh, $rcscmd, $autorcs,
#	# misc
#	$white_cmd, @unwo_cmd, $check_for_updates,
#);
#
##########################################################################
# read/write resource file and history file

#sub whichconfigfile {
#	return $ENV{PFMRC} ? $ENV{PFMRC} : "$CONFIGDIRNAME/$CONFIGFILENAME";
#}

#sub write_pfmrc {
#	my @resourcefile;
#	my $secs_per_32_days = 60 * 60 * 24 * 32;
#	my $maxdatelen = 0;
#	# the default layouts assume that the default timestamp format is 15 chars wide.
#	# find out if this is enough, taking the current locale into account.
#	foreach (0 .. 11) {
#		$maxdatelen = max($maxdatelen, length strftime("%b", gmtime($secs_per_32_days * $_)));
#	}
#	$maxdatelen -= 3;
#	if (open MKPFMRC, '>' . whichconfigfile()) {
#		# both __DATA__ and __END__ markers are used at the same time
#		while (($_ = <DATA>) !~ /^__END__$/) {
#			s/^(##? Version )x$/$1$VERSION/m;
#			if ($^O =~ /linux/i) {
#				s{^(\s*(?:your\[[[:alpha:]]\]|launch\[[^]]+\])\s*:\s*\w+.*?\s+)more(\s*)$}
#				 {$1less$2}mg;
#			}
#			if (/nnnnn/ and $maxdatelen) {
#				s/([cma])/$1 x ($maxdatelen+1)/e &&
#				s/nnnnn{$maxdatelen}/nnnn/;
#			}
#			print MKPFMRC;
#		}
#		close DATA;
#		close MKPFMRC;
#	} # no success? well, that's just too bad
#}

#sub PFM::Config::read {
#	%pfmrc = ();
#	unless (-r whichconfigfile()) {
#		unless ($ENV{PFMRC} || -d $CONFIGDIRNAME) {
#			# only make directory for default location ($ENV{PFMRC} unset)
#			mkdir $CONFIGDIRNAME, $CONFIGDIRMODE;
#		}
#		write_pfmrc();
#	}
#	if (open PFMRC, whichconfigfile()) {
#		while (<PFMRC>) {
#			# the pragma 'locale' causes problems with reading in the configfile when using UTF-8
#			no locale;
#			if (/# Version ([\w\.]+)$/ and $1 lt $VERSION and !$_[0]) {
#				# will not be in message color: usecolor not yet parsed
#				neat_error(
#					"Warning: your $CONFIGFILENAME version $1 may be outdated.\r\n"
#				.	"Please see pfm(1), under DIAGNOSIS."
#				);
#				$scr->key_pressed($IMPORTANTDELAY);
#			}
#			s/#.*//;
#			if (s/\\\n?$//) { $_ .= <PFMRC>; redo; }
##			if (/^\s*([^:[\s]+(?:\[[^]]+\])?)\s*:\s*(.*)$/o) {
#			if (/^[ \t]*([^: \t[]+(?:\[[^]]+\])?)[ \t]*:[ \t]*(.*)$/o) {
##				print STDERR "-$1";
#				$pfmrc{$1} = $2;
#			}
#		}
#		close PFMRC;
#	}
#	goto &parse_pfmrc;
#}
#
#sub parse_pfmrc { # $readflag - show copyright only on startup (first read)
#	local $_;
#	my ($termkeys, $oldkey);
#	%dircolors = %framecolors = %filetypeflags = ();
#	# 'usecolor' - find out when color must be turned _off_
#	if (defined($ENV{ANSI_COLORS_DISABLED}) or isno($pfmrc{usecolor})) {
#		$scr->colorizable(0);
#	} elsif ($pfmrc{usecolor} eq 'force') {
#		$scr->colorizable(1);
#	}
#	# 'copyrightdelay', 'cursorveryvisible', 'erase', 'keymap'
#	copyright($pfmrc{copyrightdelay}) unless $_[0];
#	$cursorveryvisible = isyes($pfmrc{cursorveryvisible});
#	system ('tput', $cursorveryvisible ? 'cvvis' : 'cnorm');
#	system ('stty', 'erase', $pfmrc{erase})	if defined($pfmrc{erase});
#	$kbd->set_keymap($pfmrc{keymap})		if $pfmrc{keymap};
#	# time/date format for clock and timestamps
#	$pfmrc{clockdateformat} ||= '%Y %b %d';
#	$pfmrc{clocktimeformat} ||= '%H:%M:%S';
#	$pfmrc{timestampformat} ||= '%y %b %d %H:%M';
#	# some configuration options are NOT fetched into common scalars
#	# (e.g. confirmquit) - however, they remain accessable in %pfmrc
#	# don't change initialized settings that are modifiable by key commands
#	$check_for_updates  = isyes($pfmrc{checkforupdates});
#	$clsonexit			= isyes($pfmrc{clsonexit});
#	$waitlaunchexec		= isyes($pfmrc{waitlaunchexec});
#	$autowritehistory	= isyes($pfmrc{autowritehistory});
#	$autoexitmultiple	= isyes($pfmrc{autoexitmultiple});
#	$mouseturnoff		= isyes($pfmrc{mouseturnoff});
#	$swap_persistent	= isyes($pfmrc{persistentswap});
#	$trspace			= isyes($pfmrc{translatespace}) ? ' ' : '';
#	$dotdot_mode		= isyes($pfmrc{dotdotmode});
#	$autorcs			= isyes($pfmrc{autorcs});
#	$remove_marks_ok	= isyes($pfmrc{remove_marks_ok});
#	$white_mode			= isyes($pfmrc{defaultwhitemode})	if !defined $white_mode;
#	$dot_mode			= isyes($pfmrc{defaultdotmode})		if !defined $dot_mode;
#	$clobber_mode		= isyes($pfmrc{defaultclobber})		if !defined $clobber_mode;
#	$sort_mode			= $pfmrc{defaultsortmode}	|| 'n'	if !defined $sort_mode;
#	$radix_mode			= $pfmrc{defaultradix}		|| 'hex'	if !defined $radix_mode;
#	$path_mode			= $pfmrc{defaultpathmode}	|| 'log'	if !defined $path_mode;
#	$currentlayout		= $pfmrc{defaultlayout}		||  0		if !defined $currentlayout;
#	$e					= $pfmrc{escapechar}		|| '=';
#	$rdevtomajor		= $RDEVTOMAJOR{$^O} || $RDEVTOMAJOR{default};
#	$ducmd				= $pfmrc{ducmd} || $DUCMDS{$^O} || $DUCMDS{default};
#	$ducmd				=~ s/\$\{e\}/$e/g;
#	$mouse_mode			= $pfmrc{defaultmousemode}	|| 'xterm' if !defined $mouse_mode;
#	$mouse_mode			= ($mouse_mode eq 'xterm' && isxterm($ENV{TERM})) || isyes($mouse_mode);
#	# shouldn't this be !defined $pfmrc{altscreen_mode} ?
#	$altscreen_mode		= $pfmrc{altscreenmode}		|| 'xterm' if !defined $altscreen_mode;
#	$altscreen_mode		= ($altscreen_mode eq 'xterm' && isxterm($ENV{TERM})) || isyes($altscreen_mode);
#	$chdirautocmd		= $pfmrc{chdirautocmd};
#	$rcscmd				= $pfmrc{rcscmd} || 'svn status';
#	($windowcmd)		= ($pfmrc{windowcmd}) ||
#						  ($^O eq 'linux' ? 'gnome-terminal -e' : 'xterm -e');
#	($printcmd)			= ($pfmrc{printcmd}) ||
#						  ($ENV{PRINTER} ? "lpr -P$ENV{PRINTER} ${e}2" : "lpr ${e}2");
#	$showlockchar		= ( $pfmrc{showlock} eq 'sun' && $^O =~ /sun|solaris/i
#						  or isyes($pfmrc{showlock}) ) ? 'l' : 'S';
#	$ident_mode			= $IDENTMODES{$pfmrc{defaultident}} || 0 if !defined $ident_mode;
#	$viewer				= $pfmrc{viewer} || 'xv';
#	$editor				= $ENV{VISUAL} || $ENV{EDITOR}  || $pfmrc{editor} || 'vi';
#	$pager				= $ENV{PAGER}  || $pfmrc{pager} || ($^O =~ /linux/i ? 'less' : 'more');
#	# flags
#	if ($pfmrc{filetypeflags} eq 'dirs') {
#		%filetypeflags = ( d => $FILETYPEFLAGS{d} );
#	} elsif (isyes($pfmrc{filetypeflags})) {
#		%filetypeflags = %FILETYPEFLAGS;
#	} else {
#		%filetypeflags = ();
#	}
#	# split 'columnlayouts'
#	@columnlayouts     = split(/:/, ( $pfmrc{columnlayouts}
#		? $pfmrc{columnlayouts}
#		:	'* nnnnnnnnnnnnnnnnnnnnnnnnnnnssssssss mmmmmmmmmmmmmmmm pppppppppp ffffffffffffff:'
#		.	'* nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnssssssss mmmmmmmmmmmmmmmm ffffffffffffff:'
#		.	'* nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnssssssss uuuuuuuu pppppppppp ffffffffffffff:'
#	));
#	# additional key definitions 'keydef'
#	if ($termkeys = $pfmrc{'keydef[*]'} .':'. $pfmrc{"keydef[$ENV{TERM}]"}) {
#		$termkeys =~ s/(\\e|\^\[)/\e/gi;
#		# this does not allow : chars to appear in escape sequences!
#		foreach (split /:/, $termkeys) {
#			/^(\w+)=(.*)/ and $scr->def_key($1, $2);
#		}
#	}
#	# init colorsets, ornaments, ident, formatlines, enable mouse
#	parse_colorsets();
#	setornaments();
#	initident();
#	makeformatlines();
#	mouseenable($mouse_mode);
#	alternate_screen($ALTERNATE_ON) if $altscreen_mode;
#}

#sub parse_colorsets {
#	if (isyes($pfmrc{importlscolors}) and $ENV{LS_COLORS} || $ENV{LS_COLOURS}){
#		$pfmrc{'dircolors[ls_colors]'} =  $ENV{LS_COLORS} || $ENV{LS_COLOURS};
#	}
#	$pfmrc{'dircolors[off]'}   = '';
#	$pfmrc{'framecolors[off]'} =
#		'title=reverse:swap=reverse:footer=reverse:highlight=bold:';
#	# this %{{ }} construct keeps values unique
#	@colorsetnames = keys %{{
#		map { /\[(\w+)\]/; $1, '' }
#		grep { /^(dir|frame)colors\[[^*]/ } keys(%pfmrc)
#	}};
#	# keep the default outside of @colorsetnames
#	defined($pfmrc{'dircolors[*]'})   or $pfmrc{'dircolors[*]'}   = '';
#	defined($pfmrc{'framecolors[*]'}) or $pfmrc{'framecolors[*]'} =
#		'header=white on blue:multi=bold reverse cyan on white:'
#	.	'title=bold reverse cyan on white:swap=reverse black on cyan:'
#	.	'footer=bold reverse blue on white:message=bold cyan:highlight=bold:';
#	foreach (@colorsetnames) {
#		# should there be no dircolors[thisname], use the default
#		defined($pfmrc{"dircolors[$_]"})
#			or $pfmrc{"dircolors[$_]"} = $pfmrc{'dircolors[*]'};
#		while ($pfmrc{"dircolors[$_]"} =~ /([^:=*]+)=([^:=]+)/g ) {
#			$dircolors{$_}{$1} = $2;
#		}
#		# should there be no framecolors[thisname], use the default
#		defined($pfmrc{"framecolors[$_]"})
#			or $pfmrc{"framecolors[$_]"} = $pfmrc{'framecolors[*]'};
#		while ($pfmrc{"framecolors[$_]"} =~ /([^:=*]+)=([^:=]+)/g ) {
#			$framecolors{$_}{$1} = $2;
#		}
#	}
#	# now set color_mode if unset
#	$color_mode ||= defined($ENV{ANSI_COLORS_DISABLED})
#		? 'off'
#		: $pfmrc{defaultcolorset} || (defined $dircolors{ls_colors} ? 'ls_colors' : $colorsetnames[0]);
#}

#sub write_history {
#	my $failed;
#	$scr->at(0,0)->clreol();
#	foreach (keys(%HISTORIES)) {
#		if (open (HISTFILE, ">$CONFIGDIRNAME/$_")) {
#			print HISTFILE join "\n", @{$HISTORIES{$_}}, '';
#			close HISTFILE;
#		} elsif (!$failed) {
#			putmessage("Unable to save (part of) history: $!");
#			$failed++; # warn only once
#		}
#	}
#	putmessage('History written successfully') unless $failed;
#	$scr->key_pressed($ERRORDELAY);
#	$scr->key_pressed($IMPORTANTDELAY) if $failed;
#	return $R_MENU;
#}
#
#sub read_history {
#	my $hfile;
#	# some defaults - set them here because $e is known only now
#	@command_history = ('du -ks * | sort -n', "man ${e}1");
#	@mode_history	 = ('755', '644');
#	@path_history	 = ('/', $ENV{HOME});
#	@regex_history	 = ('\.jpg$');
##	@time_history;
##	@perlcmd_history;
#	foreach (keys(%HISTORIES)) {
#		$hfile = "$CONFIGDIRNAME/$_";
#		if (-s $hfile and open (HISTFILE, $hfile)) {
#			chomp( @{$HISTORIES{$_}} = <HISTFILE> );
#			close HISTFILE;
#		}
#	}
#}
#
#sub write_cwd {
#	if (open CWDFILE,">$CONFIGDIRNAME/$CWDFILENAME") {
#		print CWDFILE $currentdir, "\n";
#		close CWDFILE;
#	} else {
#		putmessage("Unable to create $CONFIGDIRNAME/$CWDFILENAME: $!\n");
#	}
#	if ($swap_state && $swap_persistent && open SWDFILE,">$CONFIGDIRNAME/$SWDFILENAME") {
#		print SWDFILE $swap_state->{path}, "\n";
#		close SWDFILE;
#	} else {
#		unlink "$CONFIGDIRNAME/$SWDFILENAME";
#	}
#}
#
##########################################################################
# some translations

#sub getversion {
#	my $ver  = 'unknown';
#	my $year = 7*7*41; # don't edit this. If the year cannot be read, at least this is correct
#	# the pragma 'locale' causes problems with reading in the configfile when using UTF-8
#	no locale;
#	if ( open (SELF, $0) || open (SELF, `which $0`) ) {
#		while (<SELF>) {
#			/^#+\s+Version:\s+([\w\.]+)/ and $ver  = "$1";
#			/^#+\s+Date:\s+(\d+)/        and $year = "$1", last;
#		}
#		close SELF;
#	}
#	return ($ver, $year);
#}
#
#sub find_uid {
#	my $uid = $_[0];
#	return $usercache{$uid} || +($usercache{$uid} = scalar(defined($uid) ? getpwuid($uid) : '') || $uid);
#}
#
#sub find_gid {
#	my $gid = $_[0];
#	return $groupcache{$gid} || +($groupcache{$gid} = scalar(defined($gid) ? getgrgid($gid) : '') || $gid);
#}
#
#sub init_signames {
#	my $i = 0;
#	my @signame;
#	foreach (split(/ /, $Config{sig_name})) {
##		$signo{$name} = $i;
#		$signame[$i++] = $_;
#	}
#	return @signame;
#}
#
#sub setornaments {
#	my $messcolor = $framecolors{$color_mode}{message};
#	my @cols;
#	unless (exists $ENV{PERL_RL}) {
#		# this would have been nice, however,
#		# readline processes only the first (=most important) capability
#		push @cols, 'mr' if ($messcolor =~ /reverse/);
#		push @cols, 'md' if ($messcolor =~ /bold/);
#		push @cols, 'us' if ($messcolor =~ /under(line|score)/);
##		$kbd->ornaments(join(';', @cols) . ',me,,');
#		$kbd->ornaments($cols[0] . ',me,,');
#	}
#}

#sub formatted {
#	local $^A = '';
#	formline(shift(), @_);
#	return $^A;
#}

#sub time2str {
#	my ($time, $flag) = @_;
#	if ($flag == $TIME_FILE) {
#		return strftime ($pfmrc{timestampformat}, localtime $time);
#	} else {
#		return strftime ($pfmrc{clockdateformat}, localtime $time),
#			   strftime ($pfmrc{clocktimeformat}, localtime $time);
#	}
#}
#
#sub mode2str {
#	my $strmode;
#	my $nummode = shift; # || 0;
#	my $octmode = sprintf("%lo", $nummode);
#	$octmode	=~ /(\d\d?)(\d)(\d)(\d)(\d)$/;
#	$strmode	= substr('-pc?d?b?-nl?sDw?', oct($1) & 017, 1)
#				. $SYMBOLIC_MODES[$3] . $SYMBOLIC_MODES[$4] . $SYMBOLIC_MODES[$5];
#	# 0000                000000  unused
#	# 1000  S_IFIFO   p|  010000  fifo (named pipe)
#	# 2000  S_IFCHR   c   020000  character special
#	# 3000  S_IFMPC       030000  multiplexed character special (V7)
#	# 4000  S_IFDIR   d/  040000  directory
#	# 5000  S_IFNAM       050000  XENIX named special file with two subtypes, distinguished by st_rdev values 1,2
#	# 0001  S_INSEM   s   000001  semaphore
#	# 0002  S_INSHD   m   000002  shared data
#	# 6000  S_IFBLK   b   060000  block special
#	# 7000  S_IFMPB       070000  multiplexed block special (V7)
#	# 8000  S_IFREG   -   100000  regular
#	# 9000  S_IFNWK   n   110000  network special (HP-UX)
#	# a000  S_IFLNK   l@  120000  symbolic link
#	# b000  S_IFSHAD      130000  Solaris ACL shadow inode,not seen by userspace
#	# c000  S_IFSOCK  s=  140000  socket
#	# d000  S_IFDOOR  D>  150000  Solaris door
#	# e000  S_IFWHT   w%  160000  BSD whiteout
#	#
#	if ($2 & 4) {		substr( $strmode,3,1) =~ tr/-x/Ss/ }
#	if ($2 & 2) { eval "substr(\$strmode,6,1) =~ tr/-x/${showlockchar}s/" }
#	if ($2 & 1) {		substr( $strmode,9,1) =~ tr/-x/Tt/ }
#	return $strmode;
#}
#
#sub fit2limit {
#	my $size_power = ' ';
#	# size_num might be uninitialized or major/minor
#	my ($size_num, $limit) = @_;
#	while ($size_num > $limit) {
#		$size_num = int($size_num/1024);
#		$size_power =~ tr/KMGTPEZ/MGTPEZY/ || do { $size_power = 'K' };
#	}
#	return ($size_num, $size_power);
#}
#
sub condquotemeta { # condition, string
	return $_[0] ? quotemeta($_[1]) : $_[1];
}

sub selectednames {
	my $qif = $_[0];
	my @res =	map  {
					exclude($_, '.');
					condquotemeta($qif, $_->{name})
				}
				grep { $_->{selected} eq '*' }
				@showncontents;
#	# 'oldmark' all files at once
#	foreach (@showncontents) {
#		if ($_->{selected} eq '*') {
#			exclude($_{name}, '.');
#		}
#	}
	return @res;
}

sub expand_replace { # esc-category, namenoext, name, ext
	my $qif = shift;
	for ($_[0]) {
		/1/ and return condquotemeta($qif, $_[1]);
		/2/ and return condquotemeta($qif, $_[2]);
		/3/ and return condquotemeta($qif, $currentdir);
		/4/ and return condquotemeta($qif, $disk{mountpoint});
		/5/ and return condquotemeta($qif, $swap_state->{path}) if $swap_state;
		/6/ and return condquotemeta($qif, basename($currentdir));
		/7/ and return condquotemeta($qif, $_[3]);
		/8/ and return join (' ', selectednames($qif));
		/e/ and return condquotemeta($qif, $editor);
		/p/ and return condquotemeta($qif, $pager);
		/v/ and return condquotemeta($qif, $viewer);
		# this also handles the special $e$e case - don't quotemeta() this!
		return $_;
	}
}

sub expand_3456_escapes { # quoteif, command, whatever
	my $qif = $_[0];
	my $qe  = quotemeta $e;
	# readline understands ~ notation; now we understand it too
	$_[1] =~ s/^~(\/|$)/$ENV{HOME}\//;
	# ~user is not replaced if it is not in the passwd file
	# the format of passwd(5) dictates that a username cannot contain colons
	$_[1] =~ s/^~([^:\/]+)/(getpwnam $1)[7] || "~$1"/e;
	# the next generation in quoting
	$_[1] =~ s/$qe([^1278])/expand_replace($qif, $1)/ge;
}

sub expand_escapes { # quoteif, command, \%currentfile
	my $qif		= $_[0];
	my $name	= $_[2]{name};
	my $qe		= quotemeta $e;
	my ($namenoext, $ext);
#	$namenoext = $name =~ /^(.*)\.([^\.]+)$/ ? $1 : $name;
	# included '.' in \7
	if ($name =~ /^(.*)(\.[^\.]+)$/) {
		$namenoext = $1;
		$ext = $2;
	} else {
		$namenoext = $name;
		$ext = '';
	}
	# readline understands ~ notation; now we understand it too
	$_[1] =~ s/^~(\/|$)/$ENV{HOME}\//;
	# ~user is not replaced if it is not in the passwd file
	# the format of passwd(5) dictates that a username cannot contain colons
	$_[1] =~ s/^~([^:\/]+)/(getpwnam $1)[7] || "~$1"/e;
	# the next generation in quoting
	$_[1] =~ s/$qe(.)/expand_replace($qif, $1, $namenoext, $name, $ext)/ge;
}

#sub isxterm {
#	my $termname = shift;
#	return $termname =~ $XTERMS;
#}
#
#sub isyes {
#	return $_[0] =~ /^(1|y|yes|true|on|always)$/i;
#}
#
#sub isno {
#	return $_[0] =~ /^(0|n|no|false|off|never)$/;
#}
#
#sub min ($$) {
#	return +($_[1] < $_[0]) ? $_[1] : $_[0];
#}
#
#sub max ($$) {
#	return +($_[1] > $_[0]) ? $_[1] : $_[0];
#}
#
#sub inhibit ($$) {
#	return !$_[0] && $_[1];
#}
#
#sub triggle ($) {
#	++$_[0] > 2 and $_[0] = 0;
#	return $_[0];
#}
#
#sub toggle ($) {
#	$_[0] = !$_[0];
#}
#
#sub svnmaxchar($$) {
#	my ($a, $b) = @_;
#	if ($a eq 'C' or $b eq 'C') {
#		return 'C';
#	} elsif ($a eq 'M' or $b eq 'M'or $a eq 'A' or $b eq 'A') {
#		return 'M';
#	} elsif ($a eq '' or $a eq '-') {
#		return $b;
#	} else {
#		return $a;
#	}
#}
#
#sub svnmax($$) {
#	my ($old, $new) = @_;
#	my $res = $old;
#	substr($res,0,1) = svnmaxchar(substr($old,0,1), substr($new,0,1));
#	substr($res,1,1) = svnmaxchar(substr($old,1,1), substr($new,1,1));
#	substr($res,2,1) ||= substr($new,2,1);
#	return $res;
#}
#
##########################################################################
# more translations

#sub readintohist { # \@history, $prompt, [$default_input]
#	local $SIG{INT} = 'IGNORE'; # do not interrupt pfm
#	my $history	= shift;
#	my $prompt	= shift || '';
#	my $input	= shift || '';
#	set_term_history($kbd, @$history);
#	$input = $kbd->readline($prompt, $input);
#	if ($input =~ /\S/ and $input ne ${$history}[-1]) {
#		push (@$history, $input);
#		shift (@$history) if ($#$history > $MAXHISTSIZE);
#	}
#	return $input;
#}
#
#sub set_term_history {
#	my $keyboard = shift;
##	my $h    = _history_file;
##	if ( $keyboard->Features->{readHistory} ) {
##		$keyboard->ReadHistory($h);
##	}
##	elsif ( $keyboard->Features->{setHistory} ) {
##		if ( -e $h ) {
##			my @h = File::Slurp::read_file($h);
##			chomp @h;
##			$keyboard->SetHistory(@h);
##		}
##	}
#	if ($keyboard->Features->{setHistory}) {
#		$keyboard->SetHistory(@_);
#	}
#	# else fail silently
#	return $keyboard;
#}
#
#sub mychdir {
#	my $goal = $_[0];
#	my $result;
#	if ($goal eq '') {
#		$goal = $ENV{HOME};
#	} elsif (-d $goal and $goal !~ m!^/!) {
#		$goal = "$currentdir/$goal";
#	} elsif ($goal !~ m!/!) {
#		foreach (split /:/, $ENV{CDPATH}) {
#			if (-d "$_/$goal") {
#				$goal = "$_/$goal";
#				$scr->at(0,0)->clreol();
#				display_error("Using $goal");
#				$scr->at(0,0);
#				last;
#			}
#		}
#	}
#	$goal = canonicalize_path($goal);
#	if ($result = chdir $goal and $goal ne $currentdir) {
#		$oldcurrentdir = $currentdir;
#		$currentdir = $goal;
#		system("$chdirautocmd") if length($chdirautocmd);
#	}
#	return $result;
#}
#
#sub dirname {
#	$_[0] =~ m!^(.*)/.+?!;
#	return length($1) ? $1
#					  : $_[0] =~ m!^/! ? '/'
#									   : '.';
#}
#
#sub basename {
#	$_[0] =~ /\/([^\/]*)\/?$/; # ok, it has LTS but this looks better in vim
#	return length($1) ? $1 : $_[0];
#}
#
sub reversepath {
	# reverses the path from target to symlink, returns the path from symlink to target
	my ($symlink_target_abs, $symlink_name_rel) = map { canonicalize_path($_) } @_;
	# $result ultimately is named as requested
	my $result = basename($symlink_target_abs);
	if ($symlink_name_rel !~ m!/!) {
		# in same dir: reversed path == rel_path
		return $result;
	}
	# lose the filename from the symlink_target_abs and symlink_name_rel, keep the directory
	$symlink_target_abs = dirname($symlink_target_abs);
	$symlink_name_rel   = dirname($symlink_name_rel);
	# reverse this path as follows:
	# foreach_left_to_right pathname element of symlink_name_rel {
	#	case '..' : prepend basename target to result
	#	case else : prepend '..' to result
	# }
	foreach (split (m!/!, $symlink_name_rel)) {
		if ($_ eq '..') {
			$result = basename($symlink_target_abs) .'/'. $result;
			$symlink_target_abs = dirname($symlink_target_abs);
		} else {
			$result = '../'. $result;
			$symlink_target_abs .= '/'.$_;
		}
	}
	return canonicalize_path($result);
}

#sub canonicalize_path {
#	# works like realpath() but does not resolve symlinks
#	my $path = shift;
#	1 while $path =~ s!/\./!/!g;
#	1 while $path =~ s!^\./+!!g;
#	1 while $path =~ s!/\.$!!g; # keep vim happy with this !
#	1 while $path =~ s!
#		(^|/)				# start of string or following /
#		(?:\.?[^./][^/]*
#		|\.\.[^/]+)			# any filename except ..
#		/+					# any number of slashes
#		\.\.				# the name '..'
#		(?=/|$)				# followed by nothing or a slash
#		!$1!gx;
#	1 while $path =~ s!//!/!g;
#	1 while $path =~ s!^/\.\.(/|$)!/!g;
#	$path =~ s!(.)/$!$1!g; # keep vim happy with this !
#	length($path) or $path = '/';
#	return $path;
#}
#
sub reducepaths {
	# remove identical prefix from path
	my ($symlink_target_abs, $symlink_name_abs) = @_;
	my $subpath;
	while (($subpath) = ($symlink_target_abs =~ m!^(/[^/]+)(?:/|$)!)
	and index($symlink_name_abs, $subpath) == 0)
	{
		$symlink_target_abs =~ s!^/[^/]+!!;
		$symlink_name_abs   =~ s!^/[^/]+!!;
	}
	# one of these could be empty now.
	# i'm beginning to feel that all this manipulation might be easier with VMS pathnames
	return $symlink_target_abs, $symlink_name_abs;
}

sub fileforall {
	my ($index, $loopfile);
	my ($do_this, $statflag) = @_;
	if ($multiple_mode) {
		for $index (0..$#dircontents) {
			$loopfile = $dircontents[$index];
			if ($loopfile->{selected} eq '*') {
				$scr->at($PATHLINE,0)->clreol()->puts($loopfile->{name});
				exclude($loopfile, '.');
				$loopfile = $do_this->($loopfile);
				if ($statflag) {
					$dircontents[$index] = stat_entry($loopfile->{name}, $loopfile->{selected});
				}
			}
		}
		$multiple_mode = inhibit($autoexitmultiple, $multiple_mode);
	} else {
		%currentfile = %{ $do_this->(\%currentfile) };
		if ($statflag) {
			$showncontents[$currentline+$baseindex] = stat_entry($currentfile{name}, $currentfile{selected});
		}
		copyback($currentfile{name});
	}
}

sub multi_to_single {
	my $qe = quotemeta $e;
	my $do_a_refresh = $R_PATHINFO;
	if ($multiple_mode and $_[0] !~ /(?<!$qe)(?:$qe$qe)*${e}[127]/ and !-d $_[0]) {
		$scr->at(0,0);
		putmessage('Cannot do multifile operation when destination is single file.');
		$scr->at(0,0);
		$do_a_refresh |= pressanykey(); # screen might have been resized
		path_info();
		return $do_a_refresh;
	} else {
		return 0;
	}
}

sub restat_copyback {
	$showncontents[$currentline+$baseindex] = stat_entry($currentfile{name}, $currentfile{selected});
	if (!$rcsrunning and $autorcs) {
		handlemorercsopen($currentfile{name});
	}
	if ($showncontents[$currentline+$baseindex]{nlink} == 0) {
#		if ($pfmrc{keeplostfiles}) {
			$showncontents[$currentline+$baseindex]{display} .= $LOSTMSG;
#		} else {
#			splice @dircontents, $index, 1;
#			splice @showncontents, $nameindexmap{$loopfile->{name}}, 1;
#		}
	}
	copyback($currentfile{name});
}

#sub maxpan {
#	my ($temp, $width) = @_;
#	my $panspace;
#	# this is an assignment on purpose
#	if ($panspace = 2 * (length($temp) > $width)) {
#		eval "
#			\$temp =~ s/^((?:\\S+ )+?).{1,".($width - $panspace)."}\$/\$1/;
#		";
#		return $temp =~ tr/ //;
#	} else {
#		return 0;
#	};
#}
#
sub exclude { # $entry,$oldmark
	my ($entry, $oldmark) = @_;
	$oldmark ||= " ";
	$entry->{selected} = $oldmark;
	$selected_nr_of{$entry->{type}}--;
	$entry->{type} =~ /-/ and $selected_nr_of{bytes} -= $entry->{size};
}

sub include { # $entry
	my $entry = $_[0];
	$entry->{selected} = "*";
	$selected_nr_of{$entry->{type}}++;
	$entry->{type} =~ /-/ and $selected_nr_of{bytes} += $entry->{size};
}

#sub reformat {
#	foreach (@dircontents) {
#		$_->{name_too_long} = length($_->{display}) > $maxfilenamelength-1
#			? $NAMETOOLONGCHAR : ' ';
#		unless ($_->{type} =~ /[bc]/) {
#			@{$_}{qw(size_num size_power)} =
#				fit2limit($_->{size}, $maxfilesizelength);
#		}
#		@{$_}{qw(grand_num grand_power)} =
#			fit2limit($_->{grand}, $maxgrandtotallength);
#		@{$_}{qw(atimestr ctimestr mtimestr)} =
#			map { $_pfm->directory->stamp2str($_) } @{$_}{qw(atime ctime mtime)};
#	}
#}
#
sub dirlookup {
	# this assumes that the entry will be found
	my ($name, @array) = @_;
	my $found = $#array;
	while ($found >= 0 and $array[$found]{name} ne $name) {
		$found--;
	}
	return $found;
}

sub followmode {
	my %currentfile = %{$_[0]};
	return $currentfile{type} ne 'l'
		   ? $currentfile{mode}
		   : mode2str((stat $currentfile{name})[2]);
}

sub copyback {
	# copy a changed entry from @showncontents back to @dircontents
	$dircontents[dirlookup($_[0], @dircontents)] = $showncontents[$currentline+$baseindex];
}

#sub isorphan {
#	return ! -e $_[0];
#}
#
#sub resizecatcher {
#	$wasresized = 1;
#	$SIG{WINCH} = \&resizecatcher;
#}
#
sub quitcatcher {
	$wasquit = 1;
#	$SIG{QUIT} = \&quitcatcher;
}

sub reaper {
	(wait() == -1) ? 0 : $?;
#	$SIG{CHLD} = \&reaper;
}

#sub mouseenable {
#	if ($_[0]) {
#		print "\e[?9h";
#	} else {
#		print "\e[?9l";
#	}
#}
#
#sub alternate_screen {
#	if ($_[0]) {
#		print "\e[?47h";
#	} else {
#		print "\e[?47l";
#	}
#}
#
#sub stty_raw {
#	if ($_[0]) {
#		system qw(stty -raw echo);
#		$scr->echo();
#	} else {
#		system qw(stty raw -echo);
#		$scr->noecho();
#	}
#}
#
sub testdirempty {
	opendir TESTDIR, $_[0];
	readdir TESTDIR;					# every directory has at least a '.' entry
	readdir TESTDIR;					# and a '..' entry
	my $third_entry = readdir TESTDIR;	# but not necessarily a third entry
	closedir TESTDIR;
	# if the directory could not be read at all, this will return true.
	# instead of catching the exception here, we will simply wait for 'unlink' to return false
	return !$third_entry;
}

#sub white_commands {
#	$white_cmd = '';
#	@unwo_cmd  = ();
#	foreach (split /:/, $ENV{PATH}) {
#		if (!@unwo_cmd) {
#			if (-f "$_/unwhiteout") {
#				@unwo_cmd = qw(unwhiteout);
#			} elsif (-f "$_/unwo") {
#				@unwo_cmd = qw(unwo);
#			}
#		}
#		if (!$white_cmd) {
#			if (-f "$_/listwhite") {
#				$white_cmd = 'listwhite';
#			} elsif (-f "$_/lsw") {
#				$white_cmd = 'lsw';
#			}
#		}
#	}
#	unless (@unwo_cmd) {
#		@unwo_cmd = qw(rm -W);
#	}
#}

#sub globalinit {
#	my ($startingdir, $opt_version, $opt_help);
#	Getopt::Long::Configure(qw'bundling permute');
#	GetOptions ('s|swap=s'   => \$swapstartdir,
#				'l|layout=i' => \$currentlayout,
#				'h|help'     => \$opt_help,
#				'v|version'  => \$opt_version) or $opt_help = 2;
#	usage()			if $opt_help;
#	printversion()	if $opt_version;
#	exit 1			if $opt_help == 2;
#	exit 0			if $opt_help or $opt_version;
#	$startingdir = shift @ARGV;
#	$SIG{WINCH}  = \&resizecatcher;
#	# PFM::Config::read() needs $kbd for setting keymap and ornaments
#	$kbd = new Term::ReadLine 'pfm';
#	$scr = new Term::ScreenColor;
#	$scr->clrscr();
#	if ($scr->rows()) { $screenheight = $scr->rows()-$BASELINE-2 }
#	if ($scr->cols()) { $screenwidth  = $scr->cols() }
#	@signame		= init_signames();
#	%selected_nr_of	= %total_nr_of   = ();
#	$swap_mode		= $multiple_mode = 0;
#	$swap_state		= 0;
#	$currentpan		= 0;
#	$baseindex		= 0;
#	white_commands();
#	PFM::Config::read($READ_FIRST);
#	read_history();
#	draw_frame();
#	# now find starting directory
#	$oldcurrentdir = $currentdir = getcwd();
#	if ($startingdir ne '') {
#		unless (mychdir($startingdir)) {
#			$scr->at(0,0)->clreol();
#			display_error("$startingdir: $! - using .");
#			$scr->key_pressed($IMPORTANTDELAY);
#		}
#	}
#}

##########################################################################
# debugging helper commands

sub dumprefreshflags {
	my $res;
	$res .= "R_QUIT\n"			if $_[0] & $R_QUIT;
	$res .= "R_INIT_SWAP\n"		if $_[0] & $R_INIT_SWAP;
	$res .= "R_NEWDIR\n"		if $_[0] & $R_NEWDIR;
	$res .= "R_DIRCONTENTS\n"	if $_[0] & $R_DIRCONTENTS;
	$res .= "R_DIRSORT\n"		if $_[0] & $R_DIRSORT;
	$res .= "R_CLEAR\n"			if $_[0] & $R_CLEAR;
	$res .= "R_DIRFILTER\n"		if $_[0] & $R_DIRFILTER;
	$res .= "R_DIRLIST\n"		if $_[0] & $R_DIRLIST;
	$res .= "R_DISKINFO\n"		if $_[0] & $R_DISKINFO;
	$res .= "R_FOOTER\n"		if $_[0] & $R_FOOTER;
	$res .= "R_HEADINGS\n"			if $_[0] & $R_HEADINGS;
	$res .= "R_PATHINFO\n"		if $_[0] & $R_PATHINFO;
	$res .= "R_MENU\n"		if $_[0] & $R_MENU;
	$res .= "R_STRIDE\n"		if $_[0] & $R_STRIDE;
	$res .= "R_NOP\n"			if $_[0] & $R_NOP;
	return $res;
}

sub convwhite {
	$showncontents[$currentline+$baseindex]{type} = 'w';
	$dircontents  [$currentline+$baseindex]{type} = 'w';
	$showncontents[$currentline+$baseindex]{mode} =~ s/^./w/;
	$dircontents  [$currentline+$baseindex]{mode} =~ s/^./w/;
}

##########################################################################
# apply color

#sub putmessage {
#	$scr->putcolored($framecolors{$color_mode}{message}, @_);
#}

#sub decidecolor {
#	my $f = shift;
#	$f->{type}	eq 'w'			and return $dircolors{$color_mode}{wh};
#	$f->{nlink} ==  0 			and return $dircolors{$color_mode}{lo};
#	$f->{type}	eq 'd'			and return $dircolors{$color_mode}{di};
#	$f->{type}	eq 'l'			and return $dircolors{$color_mode}
#											{ isorphan($f->{name}) ? 'or' : 'ln' };
#	$f->{type}	eq 'b'			and return $dircolors{$color_mode}{bd};
#	$f->{type}	eq 'c'			and return $dircolors{$color_mode}{cd};
#	$f->{type}	eq 'p'			and return $dircolors{$color_mode}{pi};
#	$f->{type}	eq 's'			and return $dircolors{$color_mode}{so};
#	$f->{type}	eq 'D'			and return $dircolors{$color_mode}{'do'};
#	$f->{type}	eq 'n'			and return $dircolors{$color_mode}{nt};
#	$f->{mode}	=~ /[xst]/		and return $dircolors{$color_mode}{ex};
#	$f->{name}	=~ /(\.\w+)$/	and return $dircolors{$color_mode}{$1};
#}
#
#sub applycolor {
#	my ($line, $length, %file) = @_;
#	$length = $length ? 255 : $maxfilenamelength-1;
#	$scr->at($line, $filenamecol)->putcolored(decidecolor(\%file), substr($file{name}, 0, $length));
#}
#
##########################################################################
# small printing routines

#sub validate_layoutnum {
#	while ($currentlayout > $#columnlayouts) {
#		$currentlayout -= @columnlayouts;
#	}
#	return $currentlayout;
#}

#sub makeformatlines {
#	my ($squeezedlayoutline, $currentlayoutline, $firstwronglayout, $prev, $letter, $trans, $temp);
#	LAYOUT: {
#		$currentlayoutline = $columnlayouts[validate_layoutnum()];
#		unless ($currentlayoutline =~ /n/o
#		    and $currentlayoutline =~ /(^f|f$)/o
#			and $currentlayoutline =~ /\*/o)
#		{
#			$firstwronglayout ||= $currentlayout || '0 but true';
#			$scr->at(0,0)->clreol();
#			display_error("Bad layout #$currentlayout: a mandatory field is missing");
#			$scr->key_pressed($IMPORTANTDELAY);
#			$currentlayout++;
#			if (validate_layoutnum() != $firstwronglayout) {
#				redo LAYOUT;
#			} else {
#				alternate_screen($ALTERNATE_OFF);
#				$scr->clrscr()->at(0,0)
#				    ->puts("Fatal error: No valid layout defined in " . whichconfigfile())
#					->at(1,0);
#				stty_raw($TERM_COOKED);
#				mouseenable($MOUSE_OFF);
#				exit 2;
#			}
#		}
#	}
#	# layouts are all based on a screenwidth of 80: elongate filename field
#	$currentlayoutline =~ s/n/'n' x ($screenwidth - 79)/e;
#	# find out the length of the filename, filesize, grand total and info fields
#	$infolength			=		($currentlayoutline =~ tr/f//);
#	$maxfilenamelength	=		($currentlayoutline =~ tr/n//);
#	$maxfilesizelength	= 10 ** ($currentlayoutline =~ tr/s// -1) -1;
#	if ($maxfilesizelength < 2) { $maxfilesizelength = 2 }
#	$maxgrandtotallength = 10 ** ($currentlayoutline =~ tr/z// -1) -1;
#	if ($maxgrandtotallength < 2) { $maxgrandtotallength = 2 }
#	# provide N, S and Z fields
#	# N = overflow char for name
#	# S = power of 1024 for size
#	# Z = power of 1024 for grand total
#	$currentlayoutline =~ s/n(?!n)/N/io;
#	$currentlayoutline =~ s/s(?!s)/S/io;
#	$currentlayoutline =~ s/z(?!z)/Z/io;
##	$currentlayoutline =~ s/(\s+)f/'F'x length($1) . 'f'/e;
##	$currentlayoutline =~ s/f(\s+)/'f' . 'F'x length($1)/e;
##	$gaplength = 
#	($temp = $currentlayoutline) =~ s/[^f].*//;
#	$filerecordcol	= length $temp;
#	$cursorcol		= index($currentlayoutline, '*');
#	$filenamecol	= index($currentlayoutline, 'n');
#	$infocol		= index($currentlayoutline, 'f');
##	$gapcol			= index($currentlayoutline, 'F');
#	foreach ($cursorcol, $filenamecol, $infocol, $filerecordcol) {
#		if ($_ < 0) { $_ = 0 }
#	}
#	# determine the layout field set (no spaces)
#	($squeezedlayoutline = $currentlayoutline) =~ tr/*nNsSzZugpacmdilvf /*nNsSzZugpacmdilvf/ds;
#	($formatname = $squeezedlayoutline) =~ s/[*SNZ]//g;
#	@layoutfields         = map { $LAYOUTFIELDS{$_} } grep { !/f/ } (split //, $squeezedlayoutline);
#	@layoutfieldswithinfo = map { $LAYOUTFIELDS{$_} }               (split //, $squeezedlayoutline);
#	# make the formatline
#	$currentformatlinewithinfo = $currentformatline = $prev = '';
#	foreach $letter (split //, $currentlayoutline) {
#		if ($letter eq ' ') {
#			$currentformatlinewithinfo .= ' ';
#		} elsif ($prev ne $letter) {
#			$currentformatlinewithinfo .= '@';
#		} else {
#			($trans = $letter) =~ tr{*nNsSzZugpacmdilvf}
#									{<<<><><<<<<<<<>><<};
#			$currentformatlinewithinfo .= $trans;
#		}
#		$prev = $letter;
#	}
#	substr($currentformatline = $currentformatlinewithinfo, $infocol, $infolength, '');
#	return $currentformatline;
#}
#
#sub pathline {
#	my ($path, $dev, $displen, $ellipssize) = @_;
#	my $overflow	 = ' ';
#	my $ELLIPSIS	 = '..';
#	my $normaldevlen = 12;
#	my $actualdevlen = max($normaldevlen, length($dev));
#	# the three in the next exp is the length of the overflow char plus the '[]'
#	my $maxpathlen   = $screenwidth - $actualdevlen -3;
#	my ($restpathlen, $disppath);
#	$dev = $dev . ' 'x max($actualdevlen -length($dev), 0);
#	FIT: {
#		# the next line is supposed to contain an assignment
#		unless (length($path) <= $maxpathlen and $disppath = $path) {
#			# no fit: try to replace (part of) the name with ..
#			# we will try to keep the first part e.g. /usr1/ because this often
#			# shows the filesystem we're on; and as much as possible of the end
#			unless ($path =~ /^(\/[^\/]+?\/)(.+)/) {
#				# impossible to replace; just truncate
#				# this is the case for e.g. /some_ridiculously_long_directory_name
#				$disppath = substr($path, 0, $maxpathlen);
#				$$displen = $maxpathlen;
#				$overflow = $NAMETOOLONGCHAR;
#				last FIT;
#			}
#			($disppath, $path) = ($1, $2);
#			$$displen = length($disppath);
#			# the one being subtracted is for the '/' char in the next match
#			$restpathlen = $maxpathlen -length($disppath) -length($ELLIPSIS) -1;
#			unless ($path =~ /(.*?)(\/.{1,$restpathlen})$/) {
#				# impossible to replace; just truncate
#				# this is the case for e.g. /usr/some_ridiculously_long_directory_name
#				$disppath = substr($disppath.$path, 0, $maxpathlen);
#				$overflow = $NAMETOOLONGCHAR;
#				last FIT;
#			}
#			# pathname component candidate for replacement found; name will fit
#			$disppath .= $ELLIPSIS . $2;
#			$$ellipssize = length($1) - length($ELLIPSIS);
#		}
#	}
#	return $disppath . ' 'x max($maxpathlen -length($disppath), 0)
#		 . $overflow . "[$dev]";
#}
#
#sub fileline { # $currentfile, @layoutfields
#	my ($currentfile, @fields) = @_;
#	return formatted($currentformatline, @{$currentfile}{@fields});
#}

#sub highlightline { # true/false
#	my $linecolor;
#	$scr->at($currentline + $BASELINE, $filerecordcol);
#	if ($_[0] == $HIGHLIGHT_ON) {
#		$linecolor = $framecolors{$color_mode}{highlight};
#		$scr->bold()		if ($linecolor =~ /bold/);
#		$scr->reverse()		if ($linecolor =~ /reverse/);
##		$scr->underline()	if ($linecolor =~ /under(line|score)/);
#		$scr->term()->Tputs('us', 1, *STDOUT)
#							if ($linecolor =~ /under(line|score)/);
#	}
#	$scr->putcolored($linecolor, fileline(\%currentfile, @layoutfields));
#	applycolor($currentline + $BASELINE, $FILENAME_SHORT, \%currentfile);
#	$scr->reset()->normal()->at($currentline + $BASELINE, $cursorcol);
#}
#
#sub markcurrentline { # letter
#	$scr->at($currentline + $BASELINE, $cursorcol)->puts($_[0]);
#}
#
#sub pressanykey {
#	putmessage("\r\n*** Hit any key to continue ***");
#	stty_raw($TERM_RAW);
#	mouseenable($MOUSE_ON) if $mouse_mode && $mouseturnoff;
#	if ($scr->getch() eq 'kmous') {
#		$scr->getch(); # discard mouse info: co-ords and button
#		$scr->getch();
#		$scr->getch();
#	};
#	# the output of the following command should start on a new line
#	# does not work correctly in TERM_RAW mode
##	$scr->puts("\n");
#	alternate_screen($ALTERNATE_ON) if $altscreen_mode;
#	return handleresize() if $wasresized;
#	return 0;
#}
#
#sub display_error {
#	putmessage(@_);
#	return $scr->key_pressed($ERRORDELAY); # return value often discarded by caller
#}
#
#sub neat_error {
#	$scr->at(0,0)->clreol();
#	display_error($_[0]);
#	if ($multiple_mode) {
#		return $R_PATHINFO;
#	} else {
#		return $R_FRAME;
#	}
#}
#
#sub ok_to_remove_marks {
#	my $sure;
#	if (!$remove_marks_ok and mark_info()) {
#		$scr->at(0,0)->clreol();
#		putmessage('OK to remove marks [Y/N]? ');
#		$sure = $scr->getch();
#		show_menu();
#		return ($sure =~ /y/i);
#	}
#	return 1;
#}
#
sub promptforboundarytime {
	my $prompt = ($_[0] eq 'a' ? 'After' : 'Before')
			   . " modification time CCYY-MM-DD hh:mm[.ss]: ";
	my $boundarytime;
	$scr->at(0,0)->clreol();
	stty_raw($TERM_COOKED);
	$boundarytime = readintohist(\@time_history, $prompt);
	# show_menu is done in handleinclude
	stty_raw($TERM_RAW);
	$boundarytime =~ tr/0-9.//dc;
	$boundarytime =~ /(....)(..)(..)(..)(..)(\...)?$/;
	$boundarytime = mktime($6, $5, $4, $3, $2-1, $1-1900, 0, 0, 0);
	return $boundarytime;
}

sub promptforwildfilename {
	my $prompt = 'Wild filename (regular expression): ';
	my $wildfilename;
	$scr->at(0,0)->clreol();
	stty_raw($TERM_COOKED);
	$wildfilename = readintohist(\@regex_history, $prompt);
	# show_menu is done in handleinclude
	stty_raw($TERM_RAW);
	eval "/$wildfilename/";
	if ($@) {
		display_error($@);
		$scr->key_pressed($IMPORTANTDELAY);
		$wildfilename = '^$';   # clear illegal regexp
	}
	return $wildfilename;
}

#sub clearcolumn {
#	my $spaces = ' ' x $infolength;
#	foreach ($BASELINE .. $BASELINE+$screenheight) {
#		$scr->at($_, $infocol)->puts($spaces);
#	}
#}

#sub path_info {
#	$scr->at($PATHLINE, 0)->puts(pathline($currentdir, $disk{'device'}));
#}

##########################################################################
# headers, footers

#sub fitbanner { # $header/footer, $screenwidth
#	my ($banner, $virtwidth) = @_;
#	my ($maxwidth, $spcount);
#	if (length($banner) > $virtwidth) {
#		$spcount  = maxpan($banner, $virtwidth);
#		$maxwidth = $virtwidth -2*($currentpan > 0) -2*($currentpan < $spcount);
#		$banner  .= ' ';
#		eval "
#			\$banner =~ s/^(?:\\S+ ){$currentpan,}?(.{1,$maxwidth}) .*/\$1/;
#		";
#		if ($currentpan > 0       ) { $banner  = '< ' . $banner; }
#		if ($currentpan < $spcount) { $banner .= ' >'; }
#	}
#	return $banner;
#}
#
#sub draw_frame {
#	show_menu();
#	show_headings($swap_mode, $HEADING_DISKINFO);
#	show_footer();
#}
#
#sub show_headings { # swap_mode, extra field
#	my ($smode, $info, @fields) = @_;
#	my $linecolor;
#	for ($info) {
#		$_ == $HEADING_DISKINFO	and $FIELDHEADINGS{diskinfo} = ' ' x ($infolength-14) . '     disk info';
#		$_ == $HEADING_SORT		and $FIELDHEADINGS{diskinfo} = 'sort mode     ' . ' ' x ($infolength-14);
#		$_ == $HEADING_SIGNAL		and $FIELDHEADINGS{diskinfo} = '  nr signal   ' . ' ' x ($infolength-14);
#		$_ == $HEADING_YCOMMAND	and $FIELDHEADINGS{diskinfo} = 'your commands ' . ' ' x ($infolength-14);
#		$_ == $HEADING_ESCAPE		and $FIELDHEADINGS{diskinfo} = 'esc legend    ' . ' ' x ($infolength-14);
#	}
##	$FIELDHEADINGS{display} = $FIELDHEADINGS{name} . ' (' . $sort_mode . ('%','')[$white_mode] . ('.','')[$dot_mode] . ')';
#	$linecolor = $smode ? $framecolors{$color_mode}{swap}
#						: $framecolors{$color_mode}{title};
#	$scr->bold()		if ($linecolor =~ /bold/);
#	$scr->reverse()		if ($linecolor =~ /reverse/);
##	$scr->underline()	if ($linecolor =~ /under(line|score)/);
#	$scr->term()->Tputs('us', 1, *STDOUT)
#						if ($linecolor =~ /under(line|score)/);
#	$scr->at(2,0)
#		->putcolored($linecolor, formatted($currentformatlinewithinfo, @FIELDHEADINGS{@fields}))
#		->reset()->normal();
#}
#
#sub header {
#	# do not take multiple mode into account at all
#	my $mode = $_[0];
#	if		($mode & $HEADER_SORT) {
#		return 'Sort by: Name, Extension, Size, Date, Type, Inode (ignorecase, reverse):';
#	} elsif ($mode & $HEADER_MORE) {
#		#return 'Bookmark Config Edit-new mkFifo sHell Kill-chld Mkdir Show-dir sVn Write-hist';
#		return 'Bookmark Config Edit-new mkFifo sHell Kill-chld Mkdir Physical-path Show-dir sVn Write-hist alTscreen';
#	} elsif ($mode & $HEADER_INCLUDE) {
#		return 'Include? Every, Oldmarks, After, Before, User or Files only:';
#	} elsif ($mode & $HEADER_LNKTYPE) {
#		return 'Absolute, Relative symlink or Hard link:';
#	} else {
#		return	'Attribute Copy Delete Edit Find tarGet Include Link More Name'
#		.		' cOmmand Print Quit Rename Show Time User sVn unWhiteout'
#		.		' eXclude Your-command siZe';
#	}
#}
#
#sub show_menu { # <special header mode>
#	my $mode    = $_[0] || ($multiple_mode * $HEADER_MULTI);
#	my $domulti = $mode & $HEADER_MULTI;
#	my ($pos, $header, $headerlength, $vscreenwidth);
#	$vscreenwidth = $screenwidth - 9 * $domulti;
#	$header       = fitbanner(header($mode), $vscreenwidth);
#	$headerlength = length($header);
#	if ($headerlength < $vscreenwidth) {
#		$header .= ' ' x ($vscreenwidth - $headerlength);
#	}
#	$scr->at(0,0);
#	if ($domulti) {
#		$scr->putcolored($framecolors{$color_mode}{multi}, 'Multiple');
#	}
#	$scr->color($framecolors{$color_mode}{header})->puts(' ' x $domulti)->puts($header)->bold();
#	while ($header =~ /[[:upper:]<>](?!nclude\?)/g) {
#		$pos = pos($header) -1;
#		$scr->at(0, $pos + 9 * $domulti)->puts(substr($header, $pos, 1));
#	}
#	$scr->reset()->normal();
#	return $headerlength;
#}
#
#sub footer {
#	return	"F1-Help F2-Back F3-Redraw F4-Color[$color_mode]"
#	.		" F5-Reread F6-Sort[$sort_mode] F7-Swap[$ONOFF{$swap_mode}]"
#	.		" F8-Include F9-Layout[$currentlayout]" # $formatname ?
#	.		" F10-Multiple[$ONOFF{$multiple_mode}] F11-Restat F12-Mouse[$ONOFF{$mouse_mode}]"
#	.		" !-Clobber[$ONOFF{$clobber_mode}]"
#	.		" .-Dotfiles[$ONOFF{$dot_mode}]"
#	.		($white_cmd ? " %-Whiteouts[$ONOFF{$white_mode}]" : '')
#	.		" \"-Pathnames[$path_mode]"
#	.		" *-Radix[$radix_mode]"
##	.		" =-Ident"
#	;
#}
#
#sub show_footer {
#	my $footer = fitbanner(footer(), $screenwidth);
#	my $linecolor;
#	$linecolor = $framecolors{$color_mode}{footer};
#	$scr->bold()		if ($linecolor =~ /bold/);
#	$scr->reverse()		if ($linecolor =~ /reverse/);
##	$scr->underline()	if ($linecolor =~ /under(line|score)/);
#	$scr->term()->Tputs('us', 1, *STDOUT)
#						if ($linecolor =~ /under(line|score)/);
#	$scr->at($BASELINE+$screenheight+1,0)
#		->putcolored($linecolor, $footer, ' ' x ($screenwidth - length $footer))
#		->reset()->normal();
#}

#sub usage {
#	my $directory = Term::ScreenColor::colored('underline', 'directory');
#	my $number    = Term::ScreenColor::colored('underline', 'number');
#	print "Usage: pfm [ -l, --layout $number ] [ $directory ] [ -s, --swap $directory ]\n",
#		  "       pfm { -h, --help | -v, --version }\n\n",
#		  "    $directory            : specify starting directory\n",
#		  "    -h, --help           : print this help and exit\n",
#		  "    -l, --layout $number  : startup with specified layout\n",
#		  "    -s, --swap $directory : specify swap directory\n",
#		  "    -v, --version        : print version information and exit\n",
#		  "\nConfiguration options will be read from \$PFMRC ", $ENV{PFMRC} ? "($ENV{PFMRC})" : "or $CONFIGDIRNAME/$CONFIGFILENAME", "\n";
#}
#
#sub printversion {
#	print "pfm $VERSION\n";
#}
#
#sub copyright {
#	# lookalike to DOS version :)
#	return
#	$scr->at(0,0)->clreol()->cyan() # %dircolors has not been set yet
#				 ->puts("PFM $VERSION for Unix and Unix-like OS's.")
#		->at(1,0)->puts("Copyright (c) 1999-$LASTYEAR Rene Uittenbogaard")
#		->at(2,0)->puts("This software comes with no warranty: see the file COPYING for details.")
#		         ->reset()->normal()->key_pressed($_[0]);
#}
#
#sub goodbye {
#	my $bye = 'Goodbye from your Personal File Manager!';
#	stty_raw($TERM_COOKED);
#	mouseenable($MOUSE_OFF);
#	alternate_screen($ALTERNATE_OFF);
#	system qw(tput cnorm) if $cursorveryvisible;
#	if ($altscreen_mode) {
#		print "\n";
#	} else {
#		if ($clsonexit) {
#			$scr->clrscr();
#		} else {
#			$scr->at(0,0)->puts(' ' x (($screenwidth-length $bye)/2) . $bye)
#			->clreol()->at($PATHLINE,0);
#		}
#	}
#	write_cwd();
#	write_history() if $autowritehistory;
#	if ($altscreen_mode or !$clsonexit) {
#		$scr->at($screenheight+$BASELINE+1,0)->clreol();
#	}
#	check_for_updates() unless !$check_for_updates;
#	# END {} block is also executed, although it is not necessary at normal exit.
#}
#
#sub check_for_updates {
#	use LWP::Simple;
#	my $latest_version;
#	my $url = 'http://p-f-m.sourceforge.net/';
#	my $pfmpage = get($url);
#	($latest_version = $pfmpage) =~ s/.*?latest version \(v?([0-9.]+[a-z]?)\).*/$1/s;
#	if ($latest_version gt $VERSION) {
#		putmessage("There is a newer version ($latest_version) available at $url\n");
#	}
#}
#
#sub credits {
#	$scr->clrscr();
#	stty_raw($TERM_COOKED);
#	my $pfm = $scr->colored('bold', 'pfm');
#	print <<"_eoCredits_";
#
#
#             $pfm for Unix and Unix-like OS's.  Version $VERSION
#             Original idea/design: Paul R. Culley and Henk de Heer
#             Author and Copyright (c) 1999-$LASTYEAR Rene Uittenbogaard
#
#
#       $pfm is distributed under the GNU General Public License version 2.
#                    $pfm is distributed without any warranty,
#             even without the implied warranties of merchantability
#                      or fitness for a particular purpose.
#                   Please read the file COPYING for details.
#
#      You are encouraged to copy and share this program with other users.
#   Any bug, comment or suggestion is welcome in order to update this product.
#
#    New versions may be obtained from http://sourceforge.net/projects/p-f-m/
#
#                For questions, remarks or suggestions about $pfm,
#                 send email to: ruittenb\@users.sourceforge.net
#
#
#                                                         any key to exit to $pfm
#_eoCredits_
#	stty_raw($TERM_RAW);
#	$scr->getch();
#}
#
##########################################################################
# system information

#sub str_informatted {
#	formatted('@' . '>' x ($infolength-1), @_);
#}
#
#sub data_informatted {
#	formatted('@' . '>' x ($infolength-7) . ' @<<<<<', @_);
#}
#
#sub user_info {
#	$scr->at($USERINFOLINE, $infocol)->putcolored(($> ? 'normal' : 'red'), str_informatted($ident));
#}
#
#sub disk_info { # %disk{ total, used, avail }
#	my @desc		= ('K tot','K usd','K avl');
#	my @values		= @disk{qw/total used avail/};
#	my $startline	= $DISKINFOLINE;
#	# I played with vt100 boxes once,      lqqqqk
#	# but I hated it.                      x    x
#	# In case someone wants to try:        mqqqqj
##	$scr->at($startline-1,$infocol)->puts("\cNlqq\cO Disk space");
#	$scr->at($startline-1, $infocol)->puts(str_informatted('Disk space'));
#	foreach (0..2) {
#		while ($values[$_] > 99_999) {
#			$values[$_] /= 1024;
#			$desc[$_] =~ tr/KMGTPEZ/MGTPEZY/;
#		}
#		$scr->at($startline+$_, $infocol)
#			->puts(data_informatted(int($values[$_]), $desc[$_]));
#	}
#}
#
#sub dir_info {
#	my @desc   = ('files','dirs ','symln','spec ');
#	my @values = @total_nr_of{'-','d','l'};
#	$values[3] = $total_nr_of{'c'} + $total_nr_of{'b'}
#			   + $total_nr_of{'p'} + $total_nr_of{'s'}
#			   + $total_nr_of{'D'} + $total_nr_of{'w'}
#			   + $total_nr_of{'n'};
#	my $startline = $DIRINFOLINE;
#	$scr->at($startline-1, $infocol)
#		->puts(str_informatted("Directory($sort_mode" . ($white_mode ? '' : '%') . ($dot_mode ? '' : '.') . ")"));
#	foreach (0..3) {
#		$scr->at($startline+$_, $infocol)
#			->puts(data_informatted($values[$_],$desc[$_]));
#	}
#}
#
#sub mark_info {
#	my @desc = ('bytes','files','dirs ','symln','spec ');
#	my @values = @selected_nr_of{'bytes','-','d','l'};
#	$values[4] = $selected_nr_of{'c'} + $selected_nr_of{'b'}
#			   + $selected_nr_of{'p'} + $selected_nr_of{'s'}
#			   + $selected_nr_of{'D'} + $selected_nr_of{'w'}
#			   + $selected_nr_of{'n'};
#	my $startline = $MARKINFOLINE;
#	my $total = 0;
#	$values[0] = join ('', fit2limit($values[0], 9_999_999));
#	$values[0] =~ s/ $//;
#	$scr->at($startline-1, $infocol)->puts(str_informatted('Marked files'));
#	foreach (0..4) {
#		$scr->at($startline+$_, $infocol)
#			->puts(data_informatted($values[$_], $desc[$_]));
#		$total += $values[$_] if $_;
#	}
#	return $total;
#}
#
#sub clock_info {
#	my ($date, $time);
#	my $line = $DATEINFOLINE;
#	($date, $time) = time2str(time, $TIME_CLOCK);
#	if ($scr->rows() > 24) {
#		$scr->at($line++, $infocol)->puts(str_informatted($date));
#	}
#	$scr->at($line++, $infocol)->puts(str_informatted($time));
#}
#
##########################################################################
# sorting subs

#sub as_requested {
#	my ($exta, $extb);
#	if ($dotdot_mode) {
#		# Oleg Bartunov requested to have . and .. unsorted (always at the top)
#		if    ($a->{name} eq '.' ) { return -1 }
#		elsif ($b->{name} eq '.' ) { return  1 }
#		elsif ($a->{name} eq '..') { return -1 }
#		elsif ($b->{name} eq '..') { return  1 }
#	}
#	SWITCH:
#	for ($sort_mode) {
#		/n/ and return		$a->{name}  cmp		$b->{name},	last SWITCH;
#		/N/ and return		$b->{name}  cmp		$a->{name},	last SWITCH;
#		/m/ and return	 lc($a->{name}) cmp  lc($b->{name}),last SWITCH;
#		/M/ and return	 lc($b->{name}) cmp  lc($a->{name}),last SWITCH;
#		/d/ and return		$a->{mtime} <=>		$b->{mtime},last SWITCH;
#		/D/ and return		$b->{mtime} <=>		$a->{mtime},last SWITCH;
#		/a/ and return		$a->{atime} <=>		$b->{atime},last SWITCH;
#		/A/ and return		$b->{atime} <=>		$a->{atime},last SWITCH;
#		/s/ and return		$a->{size}  <=>		$b->{size},	last SWITCH;
#		/S/ and return		$b->{size}  <=>		$a->{size},	last SWITCH;
#		/z/ and return		$a->{grand} <=>		$b->{grand},last SWITCH;
#		/Z/ and return		$b->{grand} <=>		$a->{grand},last SWITCH;
#		/i/ and return		$a->{inode} <=>		$b->{inode},last SWITCH;
#		/I/ and return		$b->{inode} <=>		$a->{inode},last SWITCH;
##		/v/ and return		$a->{svn}   <=>		$b->{svn},  last SWITCH;
##		/V/ and return		$b->{svn}   <=>		$a->{svn},  last SWITCH;
#		/t/ and return $a->{type}.$a->{name}
#									  cmp $b->{type}.$b->{name}, last SWITCH;
#		/T/ and return $b->{type}.$b->{name}
#									  cmp $a->{type}.$a->{name}, last SWITCH;
#		/[ef]/i and do {
#			 if ($a->{name} =~ /^(.*)(\.[^\.]+)$/) { $exta = $2."\0377".$1 }
#											 else { $exta = "\0377".$a->{name} }
#			 if ($b->{name} =~ /^(.*)(\.[^\.]+)$/) { $extb = $2."\0377".$1 }
#											 else { $extb = "\0377".$b->{name} }
#			 /e/ and return    $exta  cmp    $extb, 		last SWITCH;
#			 /E/ and return    $extb  cmp    $exta, 		last SWITCH;
#			 /f/ and return lc($exta) cmp lc($extb),		last SWITCH;
#			 /F/ and return lc($extb) cmp lc($exta),		last SWITCH;
#		};
#	}
#}
#
sub by_name {
	return $a->{name} cmp $b->{name};
}

sub alphabetically {
	return uc($a) cmp uc($b) || $a cmp $b;
}

sub escape_middle {
	# the sorting of the backslash appears to be locale-dependant
	if ($a eq "$e$e" && $b =~ /\d/) {
		return 1;
	} elsif ($b eq "$e$e" && $a =~ /\d/) {
		return -1;
	} else {
		return $a cmp $b;
	}
}

##########################################################################
# user commands

#sub handlequit { # key
#	return $R_QUIT if isno($_pfm->config->{confirmquit});
#	return $R_QUIT if $_[0] eq 'Q'; # quick quit
#	return $R_QUIT if ($pfmrc{confirmquit} =~ /marked/i and !mark_info());
#	$scr->at(0,0)->clreol();
#	putmessage('Are you sure you want to quit [Y/N]? ');
#	my $sure = $scr->getch();
#	return +($sure =~ /y/i) ? $R_QUIT : $R_MENU;
#}
#
sub handlemultiple {
	toggle($multiple_mode);
	return $R_MENU;
}

#sub handlelayouts {
#	$currentlayout++;
#	$_screen->listing->layout($startinglayout);
#}
#
#sub layout {
#	$currentlayout++;
#	makeformatlines();
#	reformat();
#	return $R_SCREEN;
#}

#sub handlerefresh {
#	return ok_to_remove_marks() ? $R_DIRCONTENTS | $R_DIRSORT | $R_SCREEN
#								: $R_NOP;
#}
#
#sub handlecolor {
#	my $index = $#colorsetnames;
#	while ($color_mode ne $colorsetnames[$index] and $index > 0) {
#		$index--;
#	}
#	if ($index-- <= 0) { $index = $#colorsetnames }
#	$color_mode = $colorsetnames[$index];
#	setornaments();
#	return $R_SCREEN;
#}
#
#sub initident {
#	chomp ($ident  = getpwuid($>)  ) unless $ident_mode == 1;
#	chomp ($ident  = `hostname`    )     if $ident_mode == 1;
#	chomp ($ident .= '@'.`hostname`)     if $ident_mode == 2;
#	return $R_DISKINFO | $R_FOOTER;
#}

sub handleident {
	triggle($ident_mode);
	goto &initident;
}

sub handleclobber {
	toggle($clobber_mode);
	return $R_FOOTER;
}

sub handlepathmode {
	$path_mode  = $path_mode eq 'phys' ? 'log' : 'phys';
	$currentdir = getcwd() if $path_mode eq 'phys';
	return $R_FOOTER | $R_PATHINFO;
}

sub handleradix {
	$radix_mode = $radix_mode eq 'hex' ? 'oct' : 'hex';
	return $R_FOOTER;
}

#sub handleresize {
#	$wasresized = 0;
#	handlefit();
#	validate_position();
#	return $R_CLRSCR;
#}
#
sub preparercscol {
	my $file = shift;
	my (%nameindexmap, $count);
	if ($file ne '' and $file ne '.') {
		%nameindexmap = map { $_->{name}, $count++ } @showncontents;
		$showncontents[$nameindexmap{$file}]{$LAYOUTFIELDS{'v'}} = '-';
		return;
	}
	foreach(0..$#showncontents) {
		$showncontents[$_]{$LAYOUTFIELDS{'v'}} = '-';
	}
}

sub handlercspipe {
	# I don't have any experience with other versioning systems.
	# If anyone wants to help me port this to other versioning systems,
	# any help would be appreciated.
	#
	my $pin = '';
	my $firstcolsize = 7;
	my ($nfound, $input, $f1, $f2, $newlinepos, %nameindexmap, $count, $mapindex,
		$topdir, $dirindex, $oldval, $svnfieldtitle);
	#
	if (!$rcsrunning and $rcs_need_refresh) {
		$_listing->show();
		highlightline($HIGHLIGHT_ON);
		$rcs_need_refresh = 0;
		return;
	}
	# check if there is data ready on the filehandle
	vec($pin,fileno(RCSPIPE),1) = 1;
	$nfound = select($pin, undef, $pin, 0);
	return if ($nfound <= 0);
	# found data to process
	if (sysread(RCSPIPE, $input, 10000) or length($rcsbuffer)) {
		$rcsbuffer .= $input;
		%nameindexmap = map { $_->{name}, $count++ } @showncontents;
		$svnfieldtitle = $LAYOUTFIELDS{'v'};
		while (($newlinepos = index($rcsbuffer,"\cJ")) >= 0) {
			# process one line of input.
			$input = substr($rcsbuffer, 0, $newlinepos);
			$rcsbuffer = substr($rcsbuffer, $newlinepos+1);
			# split line: status information and filename
			$f1 = substr($input, 0, $firstcolsize);
			$f2 = substr($input, $firstcolsize);
			if ($f2 =~ m!/!) {
				# change in subdirectory
				($topdir = $f2) =~ s!/.*!!;
				$dirindex = $nameindexmap{$topdir};
				# find highest prio marker: C > M > ? > ''
				$oldval = $showncontents[$dirindex]{$svnfieldtitle};
				$showncontents[$dirindex]{$svnfieldtitle} = svnmax($oldval, $f1);
				#
#				# if there was a change in a subdir, then show 'M' on current dir
#				$dirindex = $nameindexmap{'.'};
#				# find highest prio marker: C > M > ? > ''
#				$oldval = $showncontents[$dirindex]{$svnfieldtitle};
#				$showncontents[$dirindex]{$svnfieldtitle} = svnmax($oldval, 'M');
				next;
			}
			# change in file in current directory
			if (defined($mapindex = $nameindexmap{$f2})) {
				$showncontents[$mapindex]{$svnfieldtitle} = $f1;
			}
		}
		%currentfile = %{$showncontents[$currentline+$baseindex]};
		$_listing->show();
		highlightline($HIGHLIGHT_ON);
		# there might be more data (which we want to read now)
		# or the pipe may be empty (then we want to close it)
		# therefore, continue processing
		goto &handlercspipe;
	} else {
		close RCSPIPE;
		$rcsrunning = 0;
		$FIELDHEADINGS{'svn'} =~ s/!+$//;
		show_headings($swap_mode, $HEADING_DISKINFO);
	}
}

sub pollall { # was handlepipes
	handlercspipe();
}

sub handlemouse {
	mouseenable(toggle $mouse_mode);
	return $R_FOOTER;
}

sub handlemousedown {
	my ($stashline, %stashfile, $mbutton, $mousecol, $mouserow, $on_name);
	my $do_a_refresh = $R_NOP;
	$scr->noecho();
	$mbutton  = ord($scr->getch()) - 040;
	$mousecol = ord($scr->getch()) - 041;
	$mouserow = ord($scr->getch()) - 041;
	$scr->echo();
	# button ----------------- location clicked -----------------------
	# 		pathline		header/footer	fileln	filename	dirname
	# 1		More/Show/cd()	ctrl-U/ctrl-D	F8		Show		Show
	# 2		cOmmand			pgup/pgdn		Show	ENTER		new win
	# 3		cOmmand			pgup/pgdn		Show	ENTER		new win
	# up	------------------- three lines up ------------------------
	# down	------------------ three lines down -----------------------
	if ($mbutton == 64) {
		# wheel up
		$do_a_refresh |= handlemove('ku');
		$do_a_refresh |= handlemove('ku');
		$do_a_refresh |= handlemove('ku');
	} elsif ($mbutton == 65) {
		# wheel down
		$do_a_refresh |= handlemove('kd');
		$do_a_refresh |= handlemove('kd');
		$do_a_refresh |= handlemove('kd');
	} elsif ($mbutton == 68) {
		# shift-wheel up
		$do_a_refresh |= handlemove('ku');
	} elsif ($mbutton == 69) {
		# shift-wheel down
		$do_a_refresh |= handlemove('kd');
	} elsif ($mouserow == $PATHLINE) {
		# path line
		$do_a_refresh |= $mbutton ? handlecommand('o') : handlepathjump($mousecol);
	} elsif ($mouserow < $BASELINE) {
		# title / header
		$do_a_refresh |= $mbutton ? handlemove('pgup') : handlemove("\cU");
	} elsif ($mouserow > $screenheight + $BASELINE) {
		# footer
		$do_a_refresh |= $mbutton ? handlemove('pgdn') : handlemove("\cD");
	} elsif (($mousecol >= $infocol and $infocol > $filerecordcol)
		or   ($mousecol < $filerecordcol)
		or !defined $showncontents[$mouserow - $BASELINE + $baseindex])
	{
		# diskinfo or empty line
		return $do_a_refresh;
	} else {
		# clicked on an existing file
		$stashline   = $currentline;
		%stashfile   = %currentfile;
		# put cursor temporarily on another file
		$currentline = $mouserow - $BASELINE;
		%currentfile = %{$showncontents[$currentline+$baseindex]};
		$on_name = ($mousecol >= $filenamecol
				and $mousecol <= $filenamecol + $maxfilenamelength);
		if ($on_name and $mbutton) {
			if ($currentfile{type} eq 'd') {
				if ($swap_state) {
					system("$windowcmd 'pfm \Q$currentfile{name}\E -s " .
										quotemeta($swap_state->{path}) . "' &");
				} else {
					system("$windowcmd 'pfm \Q$currentfile{name}\E' &");
				}
			} else {
				$do_a_refresh |= handleenter();
			}
		} elsif (!$on_name and !$mbutton) {
			$do_a_refresh |= handleselect();
		} else {
			$do_a_refresh |= handleshow();
		}
		# restore currentfile unless we did a chdir()
		unless ($do_a_refresh & $R_NEWDIR) {
			$currentline = $stashline;
			%currentfile = %stashfile;
		}
	}
	return $do_a_refresh;
}

sub handleadvance {
	my     $do_a_refresh = handleselect();
	return $do_a_refresh | handlemove(@_); # pass ' ' key on
}

sub handlesize {
	my ($recursivesize, $command, $tempfile, $do_this);
	my ($index, $loopfile);
	my $do_a_refresh = ($R_DIRFILTER | $R_DIRLIST | $R_MENU | $R_PATHINFO | $R_DISKINFO) * $multiple_mode;
#	$do_a_refresh |= $R_DIRSORT * (lc $sort_mode eq 'z');
	markcurrentline('Z') unless $multiple_mode;
	$do_this = sub {
		$loopfile = shift;
		expand_escapes($QUOTE_ON, ($command = $ducmd), $loopfile);
		($recursivesize = `$command 2>/dev/null`) =~ s/\D*(\d+).*/$1/;
		chomp $recursivesize;
		if ($?) {
			neat_error('Could not read all directories');
			$recursivesize ||= 0;
			$do_a_refresh |= $R_SCREEN;
		}
		@{$loopfile}{qw(grand grand_num grand_power)} =
			($recursivesize, fit2limit($recursivesize, $maxgrandtotallength));
		if (join('', @layoutfields) =~ /grand/) {
			$do_a_refresh |= $multiple_mode * $R_DIRLIST;
		} elsif (!$multiple_mode) {
			# use filesize field
			$tempfile = { %$loopfile };
			# TODO next line ignores the fact that size_num could be major/minor
			@{$tempfile}{qw(size size_num size_power)} = ($recursivesize,
				fit2limit($recursivesize, $maxfilesizelength));
			$scr->at($currentline + $BASELINE, $filerecordcol)
				->puts(fileline($tempfile, @layoutfields));
			markcurrentline('Z');
			applycolor($currentline + $BASELINE, $FILENAME_SHORT,
					   \%currentfile);
			$scr->getch();
		}
		return $loopfile;
	};
	if ($multiple_mode) {
		for $index (0..$#dircontents) {
			$loopfile = $dircontents[$index];
			if ($loopfile->{selected} eq '*') {
				$scr->at($PATHLINE,0)->clreol()->puts($loopfile->{name});
				exclude($loopfile, '.');
				$loopfile = $do_this->($loopfile);
				$dircontents[$index] = $loopfile;
			}
		}
		$multiple_mode = inhibit($autoexitmultiple, $multiple_mode);
	} else {
		%currentfile = %{ $do_this->(\%currentfile) };
		$showncontents[$currentline+$baseindex] = { %currentfile };
		copyback($currentfile{name});
	}
	return $do_a_refresh;
}

#sub handlewhiteout {
#	toggle($_pfm->state->{white_mode});
#	$_pfm->browser->position_at($currentfile{name});
#	return $R_DIRLIST | $R_DIRFILTER | $R_DISKINFO | $R_FOOTER;
#}
#
#sub handledot {
#	my $self = shift;
#	toggle($_pfm->state->{dot_mode});
#	$_pfm->browser->position_at($_pfmcurrentfile{name});
#	return $R_DIRLIST | $R_DIRFILTER | $R_DISKINFO | $R_FOOTER;
#}

#sub handlecdold {
#	if (ok_to_remove_marks()) {
#		mychdir($oldcurrentdir);
#		return $R_CHDIR;
#	} else {
#		return $R_MENU;
#	}
#}
#
#sub handlepan {
#	my ($key, $mode) = @_;
#	my $width = $screenwidth - 9 * $multiple_mode;
#	my $count   = max(maxpan(header($mode), $width), maxpan(footer(), $width));
#	$currentpan = $currentpan - ($key =~ /</ and $currentpan > 0)
#							  + ($key =~ />/ and $currentpan < $count);
#	return $R_MENU | $R_FOOTER;
#}
#
sub handlefind {
	if (lc($sort_mode) eq 'n') {
		goto &handlefind_incremental;
	}
	my $findme;
	my $prompt = 'File to find: ';
	$scr->at(0,0)->clreol();
	stty_raw($TERM_COOKED);
	($findme = readintohist(\@path_history, $prompt)) =~ s/\/$//;
	if ($findme =~ /\//) { $findme = basename($findme) };
	stty_raw($TERM_RAW);
	return $R_MENU if $findme eq '';
	FINDENTRY:
	foreach (sort by_name @showncontents) {
		last FINDENTRY if $findme le ($position_at = $_->{name});
#		if (index($_->{name}, $findme) == 0) {
#			$position_at = $_->{name};
#			last FINDENTRY;
#		}
	}
	return $R_DIRLIST | $R_MENU;
}

sub handlefind_incremental {
	my ($findme, $k);
	my $jumpmouse = 1;
	my $prompt = 'File to find: ';
	my $delay = .5;
	FINDINCENTRY:
	while (1) {
		highlightline($HIGHLIGHT_ON);
		$scr->at(0,0)->clreol();
		putmessage($prompt);
		$scr->puts($findme);
		if ($jumpmouse) {
			while (!$scr->key_pressed($delay)) {
				$scr->at($currentline+$BASELINE, $cursorcol);
				last if ($scr->key_pressed($delay));
				$scr->at(0, length($prompt . $findme));
			}
		}
		$k = $scr->getch();
		highlightline($HIGHLIGHT_OFF);
		if ($k eq "\cM") {
			last FINDINCENTRY;
		} elsif ($k eq "\cH" or $k eq 'del' or $k eq "\x7F") {
			chop($findme);
#		} elsif ($k eq "\cW") {
#			$findme =~ s/(.*\s+|^)(\S+\s*)$/$1/;
		} elsif ($k eq "\cU") {
			$findme = '';
		} else {
			$findme .= $k;
		}
		$position_at = $findme;
		position_cursor_find_incremental();
		%currentfile = %{$showncontents[$currentline+$baseindex]};
#		if (!$scr->key_pressed(0)) {
			$_listing->show();
#		}
	}
	return $R_MENU;
}

#sub handlefit {
#	$scr->resize();
#	my $newheight = $scr->rows();
#	my $newwidth  = $scr->cols();
#	if ($newheight || $newwidth) {
##		$ENV{ROWS}    = $newheight;
##		$ENV{COLUMNS} = $newwidth;
#		$screenheight = $newheight - $BASELINE - 2;
#		$screenwidth  = $newwidth;
#	}
#	makeformatlines();
#	reformat();
#	return $R_CLRSCR;
#}
#
#sub handleperlcommand {
#	my $perlcmd;
#	markcurrentline('@'); # disregard multiple_mode
#	$scr->at(0,0)->clreol()->putcolored($framecolors{$color_mode}{message}, 'Enter Perl command:')
#		->at($PATHLINE,0)->clreol();
#	stty_raw($TERM_COOKED);
#	$perlcmd = readintohist(\@perlcmd_history);
#	stty_raw($TERM_RAW);
#	eval $perlcmd;
#	display_error($@) if $@;
#	return $R_SCREEN;
#}
#
sub handlemoreshow {
	my ($newname, $do_a_refresh);
	my $prompt = 'Directory Pathname: ';
	return $R_MENU unless ok_to_remove_marks();
	$scr->at(0,0)->clreol();
	stty_raw($TERM_COOKED);
	$newname = readintohist(\@path_history, $prompt);
	stty_raw($TERM_RAW);
	return $R_MENU if $newname eq '';
	$position_at = '.';
	expand_escapes($QUOTE_OFF, $newname, \%currentfile);
	if (mychdir($newname)) {
		$do_a_refresh |= $R_CHDIR;
	} else {
		display_error("$newname: $!");
		$do_a_refresh |= $R_SCREEN;
	}
	return $do_a_refresh;
}

sub handlemorebookmark {
	if ($path_history[-1] ne $currentdir) {
		push @path_history, $currentdir;
		shift (@path_history) if ($#path_history > $MAXHISTSIZE);
	}
#	$scr->at(0,0)->clreol();
#	putmessage('Current directory bookmarked');
#	$scr->key_pressed($ERRORDELAY);
	return $R_MENU;
}

sub handlemoremake {
	my ($newname, $do_a_refresh);
	my $prompt  = 'New Directory Pathname: ';
	$scr->at(0,0)->clreol();
	stty_raw($TERM_COOKED);
	$newname = readintohist(\@path_history, $prompt);
	expand_escapes($QUOTE_OFF, $newname, \%currentfile);
	stty_raw($TERM_RAW);
	return $R_MENU if $newname eq '';
#	if (!mkdir $newname, 0777) {
	if (system "mkdir -p \Q$newname\E") {
		display_error('Make dir failed');
		$do_a_refresh |= $R_SCREEN;
	} elsif (!ok_to_remove_marks()) {
		$do_a_refresh |= $R_MENU; # $R_SCREEN ?
	} elsif (!mychdir($newname)) {
		display_error("$newname: $!"); # e.g. by restrictive umask
		$do_a_refresh |= $R_SCREEN;
	} else {
		$position_at = '.';
		$do_a_refresh |= $R_CHDIR;
	}
	return $do_a_refresh;
}

sub handlemoreconfig {
	my $do_a_refresh = $R_CLRSCR;
	my $olddotdot    = $dotdot_mode;
	$scr->at(0,0)->clreol();
	if (system $editor, whichconfigfile()) {
		$scr->at(1,0);
		display_error('Editor failed');
	} else {
		PFM::Config::read($READ_AGAIN);
		if ($olddotdot != $dotdot_mode) {
			# allowed to switch dotdot mode (no key), but not sortmode (use F6)
			$position_at   = $currentfile{name};
			$do_a_refresh |= $R_DIRSORT;
		}
	}
	return $do_a_refresh;
}


sub handlemoreedit {
	my $newname;
	my $prompt  = 'New filename: ';
	$scr->at(0,0)->clreol();
	stty_raw($TERM_COOKED);
	$newname = readintohist(\@path_history, $prompt);
	expand_escapes($QUOTE_OFF, $newname, \%currentfile);
	system "$editor \Q$newname\E" and display_error('Editor failed');
	stty_raw($TERM_RAW);
	return $R_CLRSCR;
}

sub handlemorefifo {
	my ($newname, $findindex);
	my $do_a_refresh = $R_SCREEN;
	my $prompt = 'New FIFO name: ';
	$scr->at(0,0)->clreol();
	stty_raw($TERM_COOKED);
	$newname = readintohist(\@path_history, $prompt);
	expand_escapes($QUOTE_OFF, $newname, \%currentfile);
	stty_raw($TERM_RAW);
	return $R_MENU if $newname eq '';
	system "mkfifo \Q$newname\E" and display_error('Make FIFO failed');
	# is newname present in @dircontents? push otherwise
	# (this part is nearly identical to the part in handlecopyrename())
	$findindex = 0;
	$findindex++ while ($findindex <= $#dircontents and
					$newname ne $dircontents[$findindex]{name});
	if ($findindex > $#dircontents) {
		$do_a_refresh |= $R_DIRSORT;
	}
	$dircontents[$findindex] = stat_entry($newname, $dircontents[$findindex]{selected} || ' ');
	# upto here
	return $do_a_refresh;
}

sub handlemoreshell {
	alternate_screen($ALTERNATE_OFF);
	$scr->clrscr();
	stty_raw($TERM_COOKED);
#	@ENV{qw(ROWS COLUMNS)} = ($screenheight + $BASELINE + 2, $screenwidth);
	system ($ENV{SHELL} ? $ENV{SHELL} : 'sh'); # most portable
	pressanykey(); # will also put the screen back in raw mode
	alternate_screen($ALTERNATE_ON) if $altscreen_mode;
	system("$chdirautocmd") if length($chdirautocmd);
	return $R_CLRSCR;
}

sub handlemorekill {
	my $printline = $BASELINE;
	my $prompt    = 'Signal to send to child processes: ';
	my $signal    = 'TERM';
	my $err;
	show_headings($swap_mode, $HEADING_SIGNAL);
	clearcolumn();
	foreach (1 .. min($#signame, $screenheight)+1) {
		$scr->at($printline++, $infocol)->puts(sprintf('  %2d %s', $_, $signame[$_]));
	}
	$scr->at(0,0)->clreol();
	stty_raw($TERM_COOKED);
	$signal = $kbd->readline($prompt, $signal); # special case
	stty_raw($TERM_RAW);
	clearcolumn();
	return $R_MENU | $R_HEADINGS | $R_DISKINFO if $signal eq '';
	if ($signal !~ /\D/) {
		$signal = $signame[$signal];
	}
	local $SIG{$signal} = 'IGNORE';
	# the "only portable" way from perlfunc(1) doesn't seem to work for me
#	kill -$signal, $$;
	eval { kill $signal, -$$ };
	if ($@) {
		$scr->at(0,0)->clreol();
		($err = $@) =~ s/ at \S+ line \d+.\n//;
		display_error($err);
	}
	return $R_MENU | $R_PATHINFO | $R_HEADINGS | $R_DISKINFO;
}

sub handlemorealtscreen {
	return unless $altscreen_mode;
	alternate_screen($ALTERNATE_OFF);
	pressanykey();
	return $R_CLRSCR;
}

sub handlemorephyspath {
	show_menu();
	$scr->at(0,0)->clreol();
	putmessage('Current physical path:');
	$scr->at($PATHLINE, 0)->puts(pathline(getcwd(), $disk{'device'}));
	$scr->getch();
	return $R_PATHINFO | $R_MENU;
}

sub handlemorercsopen {
	my $file = shift;
	# we could have used: if (RCSPIPE->opened)
	# but then we'd need to include IO::Handle
	if (defined(fileno(RCSPIPE))) {
		close RCSPIPE;
		# another svn-status command was running.
		# run a new one for the entire directory.
		$file = '';
	}
	$rcsbuffer = '';
	$rcsrunning = 1;
	$rcs_need_refresh = 1;
	$SIG{CHLD}  = \&reaper;
	preparercscol($file);
	my $rcspid = open(RCSPIPE, "$rcscmd \Q$file\E 2>/dev/null |");
	$FIELDHEADINGS{'svn'} .= '!';
	return $R_MENU | $R_HEADINGS;
}

sub handlemore {
	local $_;
	my $do_a_refresh = $R_MENU;
	my $headerlength = show_menu($HEADER_MORE);
	my $key;
	$scr->noecho();
	MOREKEY: {
		$key = $scr->at(0, $headerlength+1)->getch();
		for ($key) {
#			/^a$/io		and $do_a_refresh |= handlemoreacl(),				last MOREKEY;
			/^s$/io		and $do_a_refresh |= handlemoreshow(),				last MOREKEY;
			/^m$/io		and $do_a_refresh |= handlemoremake(),				last MOREKEY;
			/^c$/io		and $do_a_refresh |= handlemoreconfig(),			last MOREKEY;
			/^e$/io		and $do_a_refresh |= handlemoreedit(),				last MOREKEY;
			/^h$/io		and $do_a_refresh |= handlemoreshell(),				last MOREKEY;
			/^b$/io		and $do_a_refresh |= handlemorebookmark(),			last MOREKEY;
			/^f$/io		and $do_a_refresh |= handlemorefifo(),				last MOREKEY;
			/^v$/io		and $do_a_refresh |= handlemorercsopen(),			last MOREKEY;
			/^w$/io		and $do_a_refresh |= write_history(),				last MOREKEY;
			/^t$/io		and $do_a_refresh |= handlemorealtscreen(),			last MOREKEY;
			/^p$/io		and $do_a_refresh |= handlemorephyspath(),			last MOREKEY;
			# since when has pfm become a process manager?
			/^k$/io		and $do_a_refresh |= handlemorekill(),				last MOREKEY;
			/^[<>]$/io	and do {
								handlepan($_, $HEADER_MORE);
								$headerlength = show_menu($HEADER_MORE);
								show_footer();
								redo MOREKEY;
			};
		}
	}
	return $do_a_refresh;
}

sub handleinclude { # include/exclude flag (from keypress)
	local $_;
	my $exin = shift;
	my $do_a_refresh = $R_MENU | $R_PATHINFO;
	my ($criterion, $headerlength);
	our ($wildfilename, $boundarytime, $entry);
	# $wildfilename could have been declared using my(), but that will prevent
	# changes in its value to be noticed by the anonymous sub
	$headerlength = show_menu($HEADER_INCLUDE);
	# modify header to say "exclude" when 'x' was pressed
	if ($exin =~ /x/i) {
		$scr->at(0,0)->putcolored($framecolors{$color_mode}{header}, 'Ex');
	}
	$exin =~ tr/ix/* /;
	my $key = lc($scr->at(0, $headerlength+1)->getch());
	if      ($key eq 'o') { # oldmarks
		$criterion = sub { $entry->{selected} eq '.' };
	} elsif ($key eq 'e') { # every
		$criterion = sub { $entry->{name} !~ /^\.\.?$/ };
	} elsif ($key eq 'u') { # user only
		$criterion = sub { $entry->{uid} =~ /$ENV{USER}/ };
	} elsif ($key =~ /^[ab]$/) { # after/before mtime
		if ($boundarytime = promptforboundarytime($key)) {
			# this was the behavior of PFM.COM, IIRC
			$wildfilename = promptforwildfilename();
			if ($key eq 'a') {
				$criterion = sub {
								$entry->{name} =~ /$wildfilename/
								and $entry->{mtime} > $boundarytime;
							};
			} else {
				$criterion = sub {
								$entry->{name} =~ /$wildfilename/
								and $entry->{mtime} < $boundarytime;
							};
			}
		} # if $boundarytime
	} elsif ($key eq 'f') { # regular files
		$wildfilename = promptforwildfilename();
		# it seems that ("a" =~ //) == false, that comes in handy
		$criterion    = sub {
							$entry->{name} =~ /$wildfilename/
							and $entry->{type} eq '-';
						};
	}
	if ($criterion) {
		foreach $entry (@showncontents) {
			if ($criterion->()) {
				if ($entry->{selected} eq '*' && $exin eq ' ') {
					exclude($entry);
				} elsif ($entry->{selected} eq '.' && $exin eq ' ') {
					$entry->{selected} = $exin;
				} elsif ($entry->{selected} ne '*' && $exin eq '*') {
					include($entry);
				}
				$do_a_refresh |= $R_SCREEN;
			}
		}
	}
	return $do_a_refresh;
}

sub handlercs {
	my $do_a_refresh = $R_STRIDE | $R_HEADINGS;
	my ($index, $loopfile);
	if ($multiple_mode) {
		# do the entire directory.
		handlemorercsopen();
		for $index (0..$#dircontents) {
			$loopfile = $dircontents[$index];
			if ($loopfile->{selected} eq '*') {
				exclude($loopfile, '.');
				$dircontents[$index] = $loopfile;
			}
		}
		$multiple_mode = inhibit($autoexitmultiple, $multiple_mode);
		$do_a_refresh |= $R_DIRLIST | $R_MENU;
	} else {
		handlemorercsopen($currentfile{name});
		%currentfile = %{$showncontents[$currentline+$baseindex]};
	}
	return $do_a_refresh;
}

sub handlename {
	markcurrentline(uc($_[0])); # disregard multiple_mode
	my $numformat = $NUMFORMATS{$radix_mode};
	my %otherfile = %currentfile;
	my $line;
	for ($otherfile{name}, $otherfile{target}) {
		s/\\/\\\\/;
		# this is highly magical
		s{([${trspace}\177[:cntrl:]]|[^[:ascii:]])}
		 {'\\' . sprintf($numformat, unpack('C', $1))}eg;
	}
	$line = $otherfile{name} . filetypeflag(\%otherfile) . (length($otherfile{target}) ? ' -> ' . $otherfile{target} : '');
	$scr->at($currentline+$BASELINE, $filenamecol)->putcolored($framecolors{$color_mode}{highlight}, $line, " \cH");
	applycolor($currentline+$BASELINE, $FILENAME_LONG, \%otherfile); # resets colors to normal
	if ($scr->noecho()->getch() eq '*') {
		handleradix();
		show_footer();
		$scr->echo()->at($currentline+$BASELINE, $filenamecol)->puts(' ' x length $line);
		goto &handlename;
	}
	if ($filenamecol < $infocol && $filenamecol+length($line) >= $infocol or $filenamecol+length($line) >= $screenwidth) {
		return $R_CLRSCR;
	} else {
		return $R_STRIDE;
	}
}

sub handlesort {
	# TODO: sort by 'v' and 'V' doesn't work: dir. is read fresh before sorting
	my $printline = $BASELINE;
	my %sortmodes = @SORTMODES;
	my ($i, $key, $headerlength);
	$headerlength = show_menu($HEADER_SORT);
	show_headings($swap_mode, $HEADING_SORT);
	clearcolumn();
	# we can't use foreach (keys %SORTMODES) because we would lose ordering
	foreach (grep { ($i += 1) %= 2 } @SORTMODES) { # keep keys, skip values
		$scr->at($printline++, $infocol)->puts(sprintf('%1s %s', $_, $sortmodes{$_}));
	}
	$key = $scr->at(0, $headerlength+1)->getch();
	clearcolumn();
	if ($sortmodes{$key}) {
		$sort_mode   = $key;
		$position_at = $currentfile{name};
	}
	return $R_DIRSORT | $R_SCREEN;
}

sub handlekeyell {
	# small l only
	if ($currentfile{type} eq 'd') {
		# this automagically passes the 'l' key in $_[0] to handleentry()
		goto &handleentry;
	} else {
		goto &handlesymlink;
	}
}

sub handlesymlink {
	my ($newname, $loopfile, $do_this, $multi2single, $index, $newnameexpanded,
		$targetstring, $findindex, $testname, $headerlength, $absrel,
		$simpletarget, $simplename);
	my @lncmd = $clobber_mode ? qw(ln -f) : qw(ln);
	my $do_a_refresh = $multiple_mode ? $R_DIRLIST | $R_MENU : $R_MENU;
	markcurrentline('L') unless $multiple_mode;
	$headerlength = show_menu($HEADER_LNKTYPE);
	$absrel = lc $scr->at(0, $headerlength+1)->getch();
	return $R_MENU unless $absrel =~ /^[arh]$/;
	push @lncmd, '-s' if $absrel !~ /h/;
	$scr->at(0,0)->clreol();
	stty_raw($TERM_COOKED);
	my $prompt = 'Name of new '.
		( $absrel eq 'r' ? 'relative symbolic'
		: $absrel eq 'a' ? 'absolute symbolic' : 'hard') . ' link: ';
	push (@path_history, $currentfile{name}) unless $multiple_mode;
	$newname = readintohist(\@path_history, $prompt);
	if ($#path_history > 0 and $path_history[-1] eq $path_history[-2]) {
		pop @path_history;
	}
	stty_raw($TERM_RAW);
	return $R_MENU if $newname eq '';
	$newname = canonicalize_path($newname);
	# expand \[3456] at this point as a test, but not \[1278]
	expand_3456_escapes($QUOTE_OFF, ($testname = $newname), \%currentfile);
	# assignment on purpose, executed before evaluation of return value
	return $R_MENU | $multi2single if $multi2single = multi_to_single($testname);
	$do_this = sub {
		if (-d $newnameexpanded) {
			# make sure $newname is a file (not a directory)
			$newnameexpanded .= '/'.$loopfile->{name};
		}
		if ($absrel eq 'r') {
			if ($newnameexpanded =~ m!^/!) {
				# absolute: first eliminate identical pathname prefix
				($simpletarget, $simplename) = reducepaths($currentdir.'/'.$loopfile->{name}, $newnameexpanded);
				# now make absolute path relative
				$simpletarget =~ s!^/!!;
				$simpletarget =~ s![^/]+!..!g;
				$simpletarget = dirname($simpletarget);
				# and reverse it
				$targetstring = reversepath($currentdir.'/'.$loopfile->{name}, $simpletarget.'/'.$simplename);
			} else {
				# relative: reverse path
				$targetstring = reversepath($currentdir.'/'.$loopfile->{name}, $newnameexpanded);
			}
		} else { # $absrel eq 'a'
			# hand over an absolute path
			$targetstring = $currentdir.'/'.$loopfile->{name};
		}
		if (system @lncmd, $targetstring, $newnameexpanded) {
			$do_a_refresh |= neat_error('Linking failed');
		} elsif ($newnameexpanded !~ m!/!) {
			# is newname present in @dircontents? push otherwise
			$findindex = 0;
			$findindex++ while ($findindex <= $#dircontents and
						   $newnameexpanded ne $dircontents[$findindex]{name});
			if ($findindex > $#dircontents) {
				$do_a_refresh |= $R_DIRSORT | $R_DIRFILTER | $R_DIRLIST;
			}
			$dircontents[$findindex] = stat_entry($newnameexpanded,
				$dircontents[$findindex]{selected} || ' ');
		}
	};
	if ($multiple_mode) {
		for $index (0..$#dircontents) {
			$loopfile = $dircontents[$index];
			expand_escapes($QUOTE_OFF,($newnameexpanded = $newname),$loopfile);
			if ($loopfile->{selected} eq '*') {
				$scr->at($PATHLINE,0)->clreol()->puts($loopfile->{name});
				exclude($loopfile,'.');
				$do_this->();
				$dircontents[$index] =
					stat_entry($loopfile->{name}, $loopfile->{selected});
			}
		}
		$multiple_mode = inhibit($autoexitmultiple, $multiple_mode);
	} else {
		$loopfile = \%currentfile;
		expand_escapes($QUOTE_OFF, ($newnameexpanded = $newname), $loopfile);
		$do_this->();
		restat_copyback();
	}
	return $do_a_refresh;
}

sub handleunwo {
	my ($index, $loopfile, $do_this);
	my $count = 0;
	my $do_a_refresh = $multiple_mode ? $R_DIRLIST | $R_MENU : $R_MENU;
	my $nowhiteouterror = 'Current file is not a whiteout';
	markcurrentline('W') unless $multiple_mode;
	if ($currentfile{type} ne 'w' and !$multiple_mode) {
		$scr->at(0,0)->clreol();
		display_error($nowhiteouterror);
		return $R_MENU;
	}
	$scr->at($PATHLINE,0);
	$do_this = sub {
		if ($loopfile->{type} eq 'w') {
			if (!system(@unwo_cmd, $loopfile->{name})) {
				$total_nr_of{$loopfile->{type}}--;
				exclude($loopfile) if $loopfile->{selected} eq '*';
				restat_copyback(); # TEST
			} else {
				$do_a_refresh |= neat_error('Whiteout removal failed');
			}
		} else {
			$do_a_refresh |= neat_error($nowhiteouterror);
		}
	};
	if ($multiple_mode) {
		for $index (0..$#dircontents) {
			$loopfile = $dircontents[$index];
			if ($loopfile->{selected} eq '*') {
				$scr->at($PATHLINE,0)->clreol()->puts($loopfile->{name});
				exclude($loopfile, '.');
				$do_this->();
				$dircontents[$index] = stat_entry($loopfile->{name}, $loopfile->{selected});
			}
		}
		$multiple_mode = inhibit($autoexitmultiple, $multiple_mode);
	} else {
		$loopfile = \%currentfile;
		$do_this->();
		restat_copyback();
	}
	return $do_a_refresh;
}

sub handletarget {
	my ($newtarget, $newtargetexpanded, $oldtargetok, $loopfile, $do_this, $index);
	my $do_a_refresh = $multiple_mode ? $R_DIRLIST | $R_MENU : $R_MENU;
	my $nosymlinkerror = 'Current file is not a symbolic link';
	markcurrentline('G') unless $multiple_mode;
	if ($currentfile{type} ne 'l' and !$multiple_mode) {
		$scr->at(0,0)->clreol();
		display_error($nosymlinkerror);
		return $R_MENU;
	}
	my $prompt = 'New symlink target: ';
	$scr->at(0,0)->clreol();
	stty_raw($TERM_COOKED);
	push (@path_history, $currentfile{target}) unless $multiple_mode;
	chomp($newtarget = readintohist(\@path_history, $prompt));
	if ($#path_history > 0 and $path_history[-1] eq $path_history[-2]) {
		pop @path_history;
	}
	stty_raw($TERM_RAW);
	return $R_MENU if ($newtarget eq '');
	$do_this = sub {
		if ($loopfile->{type} ne "l") {
			$scr->at(0,0)->clreol();
			display_error($nosymlinkerror);
		} else {
			$oldtargetok = 1;
			if (-d $loopfile->{name}) {
				# if it points to a dir, the symlink must be removed first
				# next line is an intentional assignment
				unless ($oldtargetok = unlink $loopfile->{name}) {
					$do_a_refresh |= neat_error($!);
				}
			}
			if ($oldtargetok and
				system qw(ln -sf), $newtargetexpanded, $loopfile->{name})
			{
				$do_a_refresh |= neat_error('Symlinking failed');
			}
		}
	};
	if ($multiple_mode) {
		for $index (0..$#dircontents) {
			$loopfile = $dircontents[$index];
			if ($loopfile->{selected} eq '*') {
				$scr->at($PATHLINE,0)->clreol()->puts($loopfile->{name});
				expand_escapes($QUOTE_OFF, ($newtargetexpanded = $newtarget), $loopfile);
				exclude($loopfile,'.');
				$do_this->();
				$dircontents[$index] = stat_entry($loopfile->{name}, $loopfile->{selected});
			}
		}
		$multiple_mode = inhibit($autoexitmultiple, $multiple_mode);
	} else {
		$loopfile = \%currentfile;
		expand_escapes($QUOTE_OFF,($newtargetexpanded = $newtarget),$loopfile);
		$do_this->();
		restat_copyback();
	}
	return $do_a_refresh;
}

sub handlechown {
	my ($newuid, $loopfile, $do_this, $index);
	my $prompt = 'New [user][:group] ';
	my $do_a_refresh = $multiple_mode ? $R_DIRLIST | $R_MENU : $R_MENU;
	markcurrentline('U') unless $multiple_mode;
	$scr->at(0,0)->clreol();
	stty_raw($TERM_COOKED);
	chomp($newuid = readintohist(\@mode_history, $prompt));
	stty_raw($TERM_RAW);
	return $R_MENU if ($newuid eq '');
	$do_this = sub {
		if (system ('chown', $newuid, $loopfile->{name})) {
			$do_a_refresh |= neat_error('Change owner failed');
		}
	};
	if ($multiple_mode) {
		for $index (0..$#dircontents) {
			$loopfile = $dircontents[$index];
			if ($loopfile->{selected} eq '*') {
				$scr->at($PATHLINE,0)->clreol()->puts($loopfile->{name});
				exclude($loopfile, '.');
				$do_this->();
				$dircontents[$index] = stat_entry($loopfile->{name}, $loopfile->{selected});
			}
		}
		$multiple_mode = inhibit($autoexitmultiple, $multiple_mode);
	} else {
		$loopfile = \%currentfile;
		$do_this->();
		restat_copyback();
	}
	return $do_a_refresh;
}

sub handlechmod {
	my ($newmode, $loopfile, $do_this, $index);
	my $prompt = 'Permissions [ugoa][-=+][rwxslt] or octal: ';
	my $do_a_refresh = $multiple_mode
					 ? $R_DIRFILTER | $R_DIRLIST | $R_MENU | $R_PATHINFO
					 : $R_MENU;
	markcurrentline('A') unless $multiple_mode;
	$scr->at(0,0)->clreol();
	stty_raw($TERM_COOKED);
	chomp($newmode = readintohist(\@mode_history, $prompt));
	stty_raw($TERM_RAW);
	return $R_MENU if ($newmode eq '');
	if ($newmode =~ s/^\s*(\d+)\s*$/oct($1)/e) {
		$do_this = sub {
			unless (chmod $newmode, $loopfile->{name}) {
				$do_a_refresh |= neat_error($!);
			}
		};
	} else {
		$do_this = sub {
			if (system 'chmod', $newmode, $loopfile->{name}) {
				$do_a_refresh |= neat_error('Change mode failed');
			}
		};
	}
	if ($multiple_mode) {
		for $index (0..$#dircontents) {
			$loopfile = $dircontents[$index];
			if ($loopfile->{selected} eq '*') {
				$scr->at($PATHLINE,0)->clreol()->puts($loopfile->{name});
				exclude($loopfile,'.');
				$do_this->();
				$dircontents[$index] =
					stat_entry($loopfile->{name},$loopfile->{selected});
			}
		}
		$multiple_mode = inhibit($autoexitmultiple, $multiple_mode);
	} else {
		$loopfile = \%currentfile;
		$do_this->();
		restat_copyback();
	}
	return $do_a_refresh;
}

sub handlecommand { # Y or O
	local $_;
	my ($key, $command, $do_this, $printstr, $prompt, $loopfile, $index, $newname);
	my $printline = $BASELINE;
	markcurrentline(uc($_[0])) unless $multiple_mode;
	clearcolumn();
	if ($_[0] =~ /y/i) { # Your
		show_headings($swap_mode, $HEADING_YCOMMAND);
		foreach (sort alphabetically keys %pfmrc) {
			if (/^your\[[[:alpha:]]\]$/ && $printline <= $BASELINE+$screenheight) {
				$printstr = $pfmrc{$_};
				$printstr =~ s/\e/^[/g;
				$scr->at($printline++, $infocol)
					->puts(sprintf('%1s %s', substr($_,5,1), substr($printstr,0,$infolength-2)));
			}
		}
		$prompt = 'Enter one of the highlighted chars below: ';
		$key = $scr->at(0,0)->clreol()->putcolored($framecolors{$color_mode}{message}, $prompt)->getch();
		clearcolumn();
		# this line is supposed to contain an assignment
		return $R_DISKINFO | $R_FRAME unless $command = $pfmrc{"your[$key]"};
		stty_raw($TERM_COOKED);
	} else { # cOmmand
		show_headings($swap_mode, $HEADING_ESCAPE);
		foreach (sort escape_middle keys %CMDESCAPES, $e) {
			if ($printline <= $BASELINE+$screenheight) {
				$scr->at($printline++, $infocol)->puts(sprintf(' %1s%1s %s', $e, $_, $CMDESCAPES{$_} || "literal $e"));
			}
		}
		$prompt = "Enter Unix command ($e" . "[1-8] or $e" . "[epv] escapes see below):";
		$scr->at(0,0)->clreol()->putcolored($framecolors{$color_mode}{message}, $prompt)
			->at($PATHLINE,0)->clreol();
		stty_raw($TERM_COOKED);
		$command = readintohist(\@command_history);
		clearcolumn();
	}
	if ($command =~ /^\s*cd\s(.*)$/) {
		$newname = $1;
		expand_escapes($QUOTE_OFF, $newname, \%currentfile);
		stty_raw($TERM_RAW);
		if (!ok_to_remove_marks()) {
			return $R_HEADER; # $R_SCREEN ?
		} elsif (!mychdir($newname)) {
			$scr->at(2,0);
			display_error("$newname: $!");
			return $R_SCREEN;
		}
		return $R_CHDIR;
	}
	unless ($command =~ /^\s*\n?$/) {
		alternate_screen($ALTERNATE_OFF);
#		$command .= "\n";
		if ($multiple_mode) {
			$scr->clrscr()->at(0,0);
			for $index (0..$#dircontents) {
				$loopfile = $dircontents[$index];
				if ($loopfile->{selected} eq '*') {
					exclude($loopfile,'.');
					$do_this = $command;
					expand_escapes($QUOTE_ON, $do_this, $loopfile);
					$scr->puts($do_this . "\n");
					system $do_this and display_error("External command failed\n");
					$dircontents[$index] =
						stat_entry($loopfile->{name},$loopfile->{selected});
					if ($dircontents[$index]{nlink} == 0) {
						$dircontents[$index]{display} .= $LOSTMSG;
					}
				}
			}
			$multiple_mode = inhibit($autoexitmultiple, $multiple_mode);
		} else { # single-file mode
			$loopfile = \%currentfile;
			expand_escapes($QUOTE_ON, $command, \%currentfile);
			$scr->clrscr()->at(0,0)->puts($command . "\n");
			system $command and display_error('External command failed');
			restat_copyback();
		}
		pressanykey();
		alternate_screen($ALTERNATE_ON) if $altscreen_mode;
	}
	stty_raw($TERM_RAW);
	return $R_CLRSCR;
}

sub handledelete {
	my ($loopfile, $do_this, $index, $success, $msg, $oldpos, $sure, %nameindexmap);
	my $count = 0;
	markcurrentline('D') unless $multiple_mode;
	if ($multiple_mode or $currentfile{nlink}) {
		$scr->at(0,0)->clreol();
		putmessage('Are you sure you want to delete [Y/N]? ');
		$sure = $scr->getch();
		return $R_MENU if $sure !~ /y/i;
	}
	$scr->at($PATHLINE,0);
	$do_this = sub {
		if ($loopfile->{name} eq '.') {
			# don't allow people to delete '.'; normally, this could be allowed
			# if it is empty, but if that leaves the parent directory empty,
			# then it can also be removed, which causes a fatal pfm error.
			$msg = 'Deleting current directory not allowed';
			$success = 0;
#		} elsif ($loopfile->{type} eq 'w') {
#			$success = !system(@unwo_cmd, $loopfile->{name});
		} elsif ($loopfile->{nlink} == 0 and $loopfile->{type} ne 'w') {
			# remove 'lost files' immediately, no confirmation needed
			$success = 1;
		} elsif ($loopfile->{type} eq 'd') {
			if (testdirempty($loopfile->{name})) {
				$success = rmdir $loopfile->{name};
			} else {
				$scr->at(0,0)->clreol();
				putmessage('Recursively delete a non-empty directory [Affirmative/Negative]? ');
				$sure = lc $scr->getch();
				$scr->at(0,0);
				if ($sure eq 'a') {
					$success = !system('rm', '-rf', $loopfile->{name});
				} else {
					$msg = 'Deletion cancelled. Directory not empty';
					$success = 0;
				}
				$scr->clreol();
			}
		} else {
			$success = unlink $loopfile->{name};
		}
		if ($success) {
			$total_nr_of{$loopfile->{type}}--;
			exclude($loopfile) if $loopfile->{selected} eq '*';
		} else { # not success
			display_error($msg || $!);
		}
	};
	if ($multiple_mode) {
		$oldpos = $currentfile{name};
		# build nameindexmap on showncontents, not dircontents.
		# this is faster than doing a dirlookup() every iteration
		%nameindexmap = map { $_->{name}, $count++ } @showncontents;
		# we must delete in reverse order because the number of directory
		# entries will decrease by deleting. This invalidates the %nameindexmap
		# for entries with index > current index.
		for $index (reverse(0..$#dircontents)) {
			$loopfile = $dircontents[$index];
			if ($loopfile->{selected} eq '*') {
				$scr->at($PATHLINE,0)->clreol()->puts($loopfile->{name});
				$do_this->();
				if ($success) {
					splice @dircontents, $index, 1;
					splice @showncontents, $nameindexmap{$loopfile->{name}}, 1;
				}
			}
		}
		# %nameindexmap may be completely invalid at this point. use dirlookup()
		if (dirlookup($oldpos, @showncontents) > 0) {
			$position_at = $oldpos;
		}
		$multiple_mode = inhibit($autoexitmultiple, $multiple_mode);
	} else {
		$loopfile = \%currentfile;
		$do_this->();
		if ($success) {
			splice @dircontents, dirlookup($loopfile->{name}, @dircontents), 1;
			splice @showncontents, $currentline+$baseindex, 1;
		}
	}
	# this prevents the cursor from running out of @showncontents;
	# otherwise, the validate_position() call is pointless
	while ($position_at eq '' and $currentline+$baseindex > $#showncontents) {
		$currentline--;
	}
	validate_position();
	return $R_SCREEN;
}

sub handleprint {
	my ($loopfile, $do_this, $command, $index);
	markcurrentline('P') unless $multiple_mode;
	$scr->at(0,0)->clreol()->putcolored($framecolors{$color_mode}{message}, 'Enter print command: ')
		->at($PATHLINE,0)->clreol();
	stty_raw($TERM_COOKED);
	# don't use readintohist : special case with command_history
#	$kbd->SetHistory(@command_history);
	set_term_history($kbd, @command_history);
	$command = $kbd->readline('',$printcmd);
	if ($command =~ /\S/
		and $command ne $printcmd
		and $command ne $command_history[$#command_history]
	) {
		push (@command_history, $command);
		shift (@command_history) if ($#command_history > $MAXHISTSIZE);
	}
	stty_raw($TERM_RAW);
	return $R_FRAME | $R_DISKINFO if $command eq '';
	if ($multiple_mode) {
		for $index (0..$#dircontents) {
			$loopfile = $dircontents[$index];
			$do_this = $command;
			expand_escapes($QUOTE_ON, $do_this, $loopfile);
			if ($loopfile->{selected} eq '*') {
				$scr->at($PATHLINE,0)->clreol()->puts($loopfile->{name});
				exclude($loopfile, '.');
				system $do_this and display_error('Print command failed');
			}
		}
		$multiple_mode = inhibit($autoexitmultiple, $multiple_mode);
	} else {
		expand_escapes($QUOTE_ON, $command, \%currentfile);
		system $command and display_error('Print command failed');
	}
	return $R_SCREEN;
}

sub handleshow {
	goto &handleentry if (followmode(\%currentfile) =~ /^d/);
	my ($loopfile,$index);
	$scr->clrscr()->at(0,0);
	stty_raw($TERM_COOKED);
	if ($multiple_mode) {
		for $index (0..$#dircontents) {
			$loopfile = $dircontents[$index];
			if ($loopfile->{selected} eq '*') {
				$scr->puts($loopfile->{name});
				exclude($loopfile,'.');
				alternate_screen($ALTERNATE_OFF);
				system "$pager \Q$loopfile->{name}\E" and display_error("Pager failed\n");
				alternate_screen($ALTERNATE_ON) if $altscreen_mode;
			}
		}
		$multiple_mode = inhibit($autoexitmultiple, $multiple_mode);
	} else {
		alternate_screen($ALTERNATE_OFF);
		system "$pager \Q$currentfile{name}\E" and display_error("Pager failed\n");
		alternate_screen($ALTERNATE_ON) if $altscreen_mode;
	}
	stty_raw($TERM_RAW);
	return $R_CLRSCR;
}

#sub handlehelp {
#	$scr->clrscr()->cooked();
#	print map { substr($_, 8)."\n" } split("\n", <<'    _eoHelp_');
#        --------------------------------------------------------------------------------
#        a     Attrib         mb  Bookmark         up, down arrow   move one line        
#        c     Copy           mc  Config pfm       k, j             move one line        
#        d DEL Delete         me  Edit new file    -, +             move ten lines       
#        e     Edit           mf  make FIFO        CTRL-E, CTRL-Y   scroll dir one line  
#        f /   find           mh  spawn sHell      CTRL-U, CTRL-D   move half a page     
#        g     tarGet         mk  Kill children    CTRL-B, CTRL-F   move a full page     
#        i     Include        mm  Make new dir     PgUp, PgDn       move a full page     
#        L     symLink        mp  Physical path    HOME, END        move to top, bottom  
#        n     Name           ms  Show directory   SPACE            mark file & advance  
#        o     cOmmand        mt  alTernate scrn   right arrow, l   enter dir            
#        p     Print          mv  sVn status all   left arrow, h    leave dir            
#        q Q   (Quick) quit   mw  Write history    ENTER            enter dir; launch    
#        r     Rename        --------------------  ESC, BS          leave dir            
#        s     Show           =   ident           ---------------------------------------
#        t     Time           *   radix            F1  help            F7  swap mode     
#        u     Uid            !   clobber          F2  prev dir        F8  mark file     
#        v     sVn status     @   perlcmd          F3  redraw screen   F9  cycle layouts 
#        w     unWhiteout     .   dotfiles         F4  cycle colors    F10 multiple mode 
#        x     eXclude        %   whiteout         F5  reread dir      F11 restat file   
#        y     Your command   "   paths log/phys   F6  sort dir        F12 toggle mouse  
#        z     siZe           ?   help             <   commands left   >   commands right
#        --------------------------------------------------------------------------------
#    _eoHelp_
##	$scr->at(12,0)->putcolored('bold yellow', 'q     Quit')->at(23,0);
#	$scr->puts("F1 or ? for more elaborate help, any other key for next screen ")->raw();
#	if ($scr->getch() =~ /(k1|\?)/) {
#		system qw(man pfm); # how unsubtle :-)
#	}
#	credits();
#	return $R_CLRSCR;
#}
#
sub handletime {
	my ($newtime, $loopfile, $do_this, $index, $do_a_refresh, @cmdopts);
	my $prompt = "Put date/time [[CC]YY]-MM-DD hh:mm[.ss]: ";
	$do_a_refresh = $multiple_mode ? $R_DIRLIST | $R_MENU : $R_MENU;
	markcurrentline('T') unless $multiple_mode;
	$scr->at(0,0)->clreol();
	stty_raw($TERM_COOKED);
	$newtime = readintohist(\@time_history, $prompt, strftime ("%Y-%m-%d %H:%M.%S", localtime time));
	if ($#time_history > 0 and $time_history[-1] eq $time_history[-2]) {
		pop @time_history;
	}
	stty_raw($TERM_RAW);
	$newtime =~ tr/0-9.//cd;
	return $R_MENU if ($newtime eq '');
	@cmdopts = ($newtime eq '.') ? () : ('-t', $newtime);
	$do_this = sub {
		if (system ('touch', @cmdopts, $loopfile->{name})) {
			$do_a_refresh |= neat_error('Touch failed');
		}
	};
	if ($multiple_mode) {
		for $index (0..$#dircontents) {
			$loopfile = $dircontents[$index];
			if ($loopfile->{selected} eq '*') {
				$scr->at($PATHLINE,0)->clreol()->puts($loopfile->{name});
				exclude($loopfile,'.');
				$do_this->();
				$dircontents[$index] = stat_entry($loopfile->{name},$loopfile->{selected});
			}
		}
		$multiple_mode = inhibit($autoexitmultiple, $multiple_mode);
	} else {
		$loopfile = \%currentfile;
		$do_this->();
		restat_copyback();
	}
	return $do_a_refresh;
}

sub handleedit {
	my ($loopfile, $index);
	alternate_screen($ALTERNATE_OFF);
	$scr->clrscr()->at(0,0);
	stty_raw($TERM_COOKED);
	if ($multiple_mode) {
		for $index (0..$#dircontents) {
			$loopfile = $dircontents[$index];
			if ($loopfile->{selected} eq '*') {
				$scr->puts($loopfile->{name});
				exclude($loopfile, '.');
				system "$editor \Q$loopfile->{name}\E" and display_error('Editor failed');
			}
		}
		$multiple_mode = inhibit($autoexitmultiple, $multiple_mode);
	} else {
		system "$editor \Q$currentfile{name}\E" and display_error('Editor failed');
		restat_copyback();
	}
	alternate_screen($ALTERNATE_ON) if $altscreen_mode;
	stty_raw($TERM_RAW);
	return $R_CLRSCR;
}

sub handlecopyrename {
	my $state    = uc $_[0];
	my @statecmd = (($state eq 'C' ? qw(cp -r)       : 'mv'), ($clobber_mode ? '-f' : '-i'));
	my $prompt   =   $state eq 'C' ? 'Destination: ' : 'New name: ';
	my ($loopfile, $index, $testname, $newname, $multi2single, $newnameexpanded,
		$do_this, $findindex, $sure);
	my $do_a_refresh = $R_MENU;
	markcurrentline($state) unless $multiple_mode;
	$scr->at(0,0)->clreol();
	stty_raw($TERM_COOKED);
	push (@path_history, $currentfile{name}) unless $multiple_mode;
	$newname = readintohist(\@path_history, $prompt);
	if ($#path_history > 0 and $path_history[-1] eq $path_history[-2]) {
		pop @path_history;
	}
	stty_raw($TERM_RAW);
	return $R_MENU if ($newname eq '');
	# expand \[3456] at this point as a test, but not \[1278]
	expand_3456_escapes($QUOTE_OFF, ($testname = $newname), \%currentfile);
	# assignment on purpose, executed before evaluation of return value
	return $R_MENU | $multi2single if $multi2single = multi_to_single($testname);
	$scr->at(1,0)->clreol() unless $clobber_mode;
	$do_this = sub {
#		if ($state eq 'C' and $loopfile->{type} =~ /[ld]/ ) { # move this outsde of do_this
#			# AIX: cp -r follows symlink
#			# Linux: cp -r copies symlink
#			$scr->at(0,0)->clreol();
#			putmessage('Copy symlinks to symlinks [Copy/Follow]? ');
#			$sure = lc $scr->getch();
#			$scr->at(0,0);
#			if ($sure eq 'a') {
#			} else {
#				$msg = 'Skipping directory';
#			}
#			$scr->clreol();
#		} elsif
		if (system @statecmd, $loopfile->{name}, $newnameexpanded) {
			$do_a_refresh |= neat_error($state eq 'C' ? 'Copy failed' : 'Move failed');
		} elsif ($newnameexpanded !~ m!/!) {
			# is newname present in @dircontents? push otherwise
			$findindex = 0;
			$findindex++ while ($findindex <= $#dircontents and
							$newnameexpanded ne $dircontents[$findindex]{name});
			if ($findindex > $#dircontents) {
				$do_a_refresh |= $R_DIRSORT;
			}
			$dircontents[$findindex] = stat_entry($newnameexpanded, $dircontents[$findindex]{selected} || ' ');
		}
	};
	stty_raw($TERM_COOKED) unless $clobber_mode;
	if ($multiple_mode) {
		for $index (0..$#dircontents) {
			$loopfile = $dircontents[$index];
			if ($loopfile->{selected} eq '*') {
				$scr->at($PATHLINE,0)->clreol()->puts($loopfile->{name});
				exclude($loopfile, '.');
				expand_escapes($QUOTE_OFF, ($newnameexpanded = $newname), $loopfile);
				$do_this->();
				$dircontents[$index] = stat_entry($loopfile->{name},$loopfile->{selected});
				if ($dircontents[$index]{nlink} == 0) {
					$dircontents[$index]{display} .= $LOSTMSG;
				}
				$do_a_refresh |= $R_SCREEN;
			}
		}
		$multiple_mode = inhibit($autoexitmultiple, $multiple_mode);
	} else {
		$loopfile = \%currentfile;
		expand_escapes($QUOTE_OFF, ($newnameexpanded = $newname), $loopfile);
		$do_this->();
		restat_copyback();
		# if ! $clobber_mode, we might have gotten an 'Overwrite?' question
		$do_a_refresh |= $R_SCREEN unless $clobber_mode;
	}
	stty_raw($TERM_RAW) unless $clobber_mode;
	return $do_a_refresh;
}

sub handlerestat {
	# i have seen these commands somewhere before..
	my $currentfile = $dircontents[$currentline+$baseindex];
	restat_copyback();
	return $R_STRIDE;
}

sub handleselect {
	# we cannot use %currentfile because we don't want to modify a copy
	my $file          = $showncontents[$currentline+$baseindex];
	my $was_selected  = $file->{selected} =~ /\*/;
	$file->{selected} = substr('* ', $was_selected, 1);
	if ($was_selected) {
		$selected_nr_of{$file->{type}}--;
		$file->{type} =~ /-/ and $selected_nr_of{bytes} -= $file->{size};
	} else {
		$selected_nr_of{$file->{type}}++;
		$file->{type} =~ /-/ and $selected_nr_of{bytes} += $file->{size};
	}
	# we need %currentfile set, so highlightline() can show the 'selected' status
	%currentfile = %$file;
	copyback($file->{name});
	highlightline($HIGHLIGHT_OFF);
	return $R_DISKINFO;
}

#sub validate_position {
#	# requirement: $showncontents[$currentline+$baseindex] is defined
#	my $do_a_refresh;
#	if ($currentline < 0) {
#		$baseindex    += $currentline;
#		$baseindex     < 0 and $baseindex = 0;
#		$currentline   = 0;
#		$do_a_refresh |= $R_DIRLIST;
#	}
#	if ($currentline > $screenheight) {
#		$baseindex    += $currentline - $screenheight;
#		$currentline   = $screenheight;
#		$do_a_refresh |= $R_DIRLIST;
#	}
#	if ($currentline + $baseindex > $#showncontents) {
#		$currentline   = $#showncontents - $baseindex;
#		$do_a_refresh |= $R_DIRLIST;
#	}
#	return $do_a_refresh;
#}
#
#sub handlescroll {
#	local $_ = $_[0];
#	return 0 if (/\cE/ && $baseindex == $#showncontents && $currentline == 0)
#			 or (/\cY/ && $baseindex == 0);
#	my $displacement = -(/^\cY$/)
#					   +(/^\cE$/);
#	$baseindex   += $displacement;
#	$currentline -= $displacement if $currentline-$displacement >= 0
#								 and $currentline-$displacement <= $screenheight;
##	validate_position();
#	return $R_DIRLIST;
#}
#
#sub handlemove {
#	local $_ = $_[0];
#	my $displacement =	-10*(/^-$/)  -(/^(?:ku|k)$/   )
#						+10*(/^\+$/) +(/^(?:kd|j| )$/)
#						+$screenheight*(/\cF|pgdn/)
#						-$screenheight*(/\cB|pgup/)
#						+int($screenheight*(/\cD/)/2)
#						-int($screenheight*(/\cU/)/2)
#						-($currentline    +$baseindex)              *(/^home$/)
#						+($#showncontents -$currentline -$baseindex)*(/^end$/ );
#	$currentline += $displacement;
#	return validate_position();
#}
#
sub launchtype {
	my $do_this;
	if (exists $pfmrc{"launch[$_[0]]"}) {
		$do_this = $pfmrc{"launch[$_[0]]"};
		expand_escapes($QUOTE_ON, $do_this, \%currentfile);
		$scr->clrscr()->at(0,0)->puts("Launch type $_[0]\n$do_this\n");
		system $do_this and display_error('Launch failed');
		return 'type_launched';
	} else {
		display_error("No launch command defined for type $_[0]\n");
		return 'type_tried';
	}
}

sub launchbyxbit {
	my $pid;
	if (followmode(\%currentfile) =~ /[xsS]/) {
		$scr->clrscr()->at(0,0)->puts("Launch executable $currentfile{name}\n");
#		if ($waitlaunchexec) {
			system "./\Q$currentfile{name}\E" and display_error('Launch failed');
#		} else {
#			$SIG{CHLD} = sub {
#				wait;
#				unless (--$childprocs) {
#					$SIG{CHLD} = 'DEFAULT';
#				}
#			};
#			if (!defined($pid = fork)) {
#				display_error("Unable to fork: $!");
#			} elsif (!$pid) {
#				# child
#				exec "./\Q$currentfile{name}\E";
#			} else {
#				# parent
#				$childprocs++;
#			}
#		}
		return 'xbit_launched';
	} else {
		return 0; # must return false to prevent "File type unknown" error
	}
}

sub launchbymagic {
	my $magic = `file \Q$currentfile{name}\E`;
	my ($re, $launched);
	MAGIC: foreach (grep /^magic\[/, keys %pfmrc) {
		($re) = (/magic\[([^]]+)\]/);
		# this will produce errors for invalid REs
		if (eval "\$magic =~ /$re/") {
			$launched = launchtype($pfmrc{$_});
			last MAGIC;
		}
	}
	if ($launched) {
		return 'magic_launched';
	} else {
		return 'magic_tried';
	}
}

sub launchbyextension {
	my ($ext) = ( $currentfile{name} =~ /(\.[^\.]+?)$/ );
	my $launched;
	if (exists $pfmrc{"extension[*$ext]"}) {
		$launched = launchtype($pfmrc{"extension[*$ext]"});
	}
	if ($launched) {
		return 'ext_launched';
	} else {
		return 'ext_tried';
	}
}

sub handleenter {
	goto &handleentry if followmode(\%currentfile) =~ /^d/;
	my $launched;
	$scr->at(0,0)->clreol()->at(0,0);
	stty_raw($TERM_COOKED);
	alternate_screen($ALTERNATE_OFF);
	LAUNCH: foreach (split /,/, $pfmrc{launchby}) {
		/magic/     and $launched = launchbymagic();
		/extension/ and $launched = launchbyextension();
		/xbit/      and $launched = launchbyxbit();
		last LAUNCH if $launched =~ /launched/;
	}
	if ($launched =~ /launched/) {
		$launched = $R_CLRSCR;
		pressanykey();
		restat_copyback();
	} elsif (defined $launched) {
		# we did try, but the file type was unknown
#		display_error('File type unknown');
#		$launched = $R_MENU;
		system "$pager \Q$currentfile{name}\E" and display_error($!);
		$launched = $R_CLRSCR;
	} else {
		# 'launchby' contains no valid entries
		display_error(q"No valid 'launchby' option in config file");
		$launched = $R_MENU;
	}
	stty_raw($TERM_RAW);
	alternate_screen($ALTERNATE_ON) if $altscreen_mode;
	return $launched;
}

sub swap_stash {
	return {
		path			=>   $currentdir,
		contents		=> [ @dircontents ],
		position		=>   $currentfile{name},
		disk			=> { %disk },
		selected		=> { %selected_nr_of },
		totals			=> { %total_nr_of },
		multiple_mode	=>   $multiple_mode,
		sort_mode		=>   $sort_mode,
		dot_mode		=>   $dot_mode,
		white_mode		=>   $white_mode,
		argvnull		=>   $0
	};
}

sub swap_fetch {
	my $state = shift;
	@dircontents    = @{$state->{contents}};
	$position_at    =   $state->{position};
	%disk           = %{$state->{disk}};
	%selected_nr_of = %{$state->{selected}};
	%total_nr_of    = %{$state->{totals}};
	$multiple_mode  =   $state->{multiple_mode};
	$sort_mode      =   $state->{sort_mode};
	$dot_mode       =   $state->{dot_mode};
	$white_mode     =   $state->{white_mode};
	$0              =   $state->{argvnull};
	return $state->{path};
}

sub handleswap {
	my $do_a_refresh = $R_HEADINGS | $R_MENU;
	my $prompt       = 'Directory Pathname: ';
	my ($temp_state, $nextdir);
	if ($swap_state and !$swap_persistent) { # swap back if ok_to_remove_marks
		if (ok_to_remove_marks()) {
			$nextdir   = swap_fetch($swap_state);
			$swap_mode = $swap_state = 0;
			$do_a_refresh |= $R_SCREEN;
		} else { # not ok to remove marks
			$do_a_refresh |= $R_MENU;
		}
	} elsif ($swap_state and $swap_persistent) { # swap persistent
		$temp_state = $swap_state;
		$swap_state = swap_stash();
		$nextdir    = swap_fetch($temp_state);
		toggle($swap_mode);
		$do_a_refresh |= $R_SCREEN;
	} else { # $swap_state = 0; ask and swap forward
		if (defined $swapstartdir) {
			$nextdir = $swapstartdir;
			undef $swapstartdir;
			$do_a_refresh |= $swap_persistent * $R_INIT_SWAP;
		} else {
			$scr->at(0,0)->clreol();
			stty_raw($TERM_COOKED);
			$nextdir = readintohist(\@path_history, $prompt);
			stty_raw($TERM_RAW);
			return $do_a_refresh if $nextdir eq '';
		}
		$swap_state    = swap_stash();
		$swap_mode     = 1;
		$sort_mode     = $pfmrc{defaultsortmode} || 'n';
		$multiple_mode = 0;
		# this was the old location of the if-block above
		# which has been moved up to enable returning sooner
		expand_escapes($QUOTE_OFF, $nextdir, \%currentfile);
		$position_at   = '.';
		$do_a_refresh |= $R_CHDIR;
	}
	if (!mychdir($nextdir)) {
		$scr->at($PATHLINE,0)->clreol();
		display_error("$nextdir: $!");
		$do_a_refresh |= $R_CHDIR; # dan maar de lucht in
	}
	handlemorercsopen() if $autorcs;
	return $do_a_refresh;
}

sub handleentry {
	my $key = shift;
	my ($tempptr, $nextdir, $success, $direction);
	if ( $key =~ /^kl|[h\e\cH]$/i ) {
		$nextdir   = '..';
		$direction = 'up';
	} else {
		$nextdir   = $currentfile{name};
		$direction = $nextdir eq '..' ? 'up' : 'down';
	}
	return $R_NOP if ($nextdir    eq '.');
	return $R_NOP if ($currentdir eq '/' && $direction eq 'up');
	return $R_NOP if !ok_to_remove_marks();
	$success = mychdir($nextdir);
	if ($success && $direction =~ /up/ ) {
		$position_at   = basename($oldcurrentdir);
	} elsif ($success && $direction =~ /down/) {
		$position_at   = '..';
	}
	unless ($success) {
		$scr->at(0,0)->clreol();
		display_error($!);
		show_menu();
	}
	return $success ? $R_CHDIR : $R_STRIDE;
}

sub handlepathjump {
	my $mousecol = shift;
	my ($baselen, $skipsize, $selecteddir);
	my $do_a_refresh = $R_NOP;
	my $pathline = pathline($currentdir,
							$disk{'device'},
							\$baselen,
							\$skipsize);
	# if part of the pathline has been left out, calculate the position
	# where the mouse would have clicked if the path had been complete
	if ($mousecol >= $baselen) {
		$mousecol += $skipsize;
	}
	$currentdir  =~ /^(.{$mousecol}	# 'mousecol' number of chars
						[^\/]*		# gobbling up all non-slash chars
						(?:\/|$))	# a slash or eoln
					  	([^\/]*)	# maybe another string of non-slash chars
					/x;
	$selecteddir = $1;
	$position_at = $2;
	if ($selecteddir eq ''
	or  $selecteddir eq $currentdir)
	{
		$do_a_refresh |= handlemoreshow();
	} elsif (ok_to_remove_marks()) {
		if (mychdir($selecteddir)) {
			$do_a_refresh |= $R_CHDIR;
		} else {
			display_error("$selecteddir: $!");
			$do_a_refresh |= $R_SCREEN;
		}
	}
	return $do_a_refresh;
}

##########################################################################
# directory browsing helper routines

#sub stat_entry { # path_of_entry, selected_flag
#	# the second argument is used to have the caller specify whether the
#	# 'selected' field of the file info should be cleared (when reading
#	# a new directory) or kept intact (when re-statting)
#	my ($entry, $selected_flag) = @_;
#	my ($ptr, $name_too_long, $target);
#	my ($device, $inode, $mode, $nlink, $uid, $gid, $rdev, $size,
#		$atime, $mtime, $ctime, $blksize, $blocks) = lstat $entry;
#	$ptr = {
#		name		=> $entry,			device		=> $device,
#		uid			=> find_uid($uid),	inode		=> $inode,
#		gid			=> find_gid($gid),	nlink		=> $nlink,
#		mode		=> mode2str($mode),	rdev		=> $rdev,
#		selected	=> $selected_flag,	grand_power	=> ' ',
#		atime		=> $atime,			size		=> $size,
#		mtime		=> $mtime,			blocks		=> $blocks,
#		ctime		=> $ctime,			blksize		=> $blksize,
#		svn			=> '-',
#		atimestring => time2str($atime, $TIME_FILE),
#		mtimestring => time2str($mtime, $TIME_FILE),
#		ctimestring => time2str($ctime, $TIME_FILE),
#	};
#	@{$ptr}{qw(size_num size_power)} = fit2limit($size, $maxfilesizelength);
#	$ptr->{type} = substr($ptr->{mode}, 0, 1);
#	if ($ptr->{type} eq 'l') {
#		$ptr->{target}  = readlink($ptr->{name});
#		$ptr->{display} = $entry . $filetypeflags{'l'}
#						. ' -> ' . $ptr->{target};
#	} elsif ($ptr->{type} eq '-' and $ptr->{mode} =~ /.[xst]/) {
#		$ptr->{display} = $entry . $filetypeflags{'x'};
#	} elsif ($ptr->{type} =~ /[bc]/) {
#		$ptr->{size_num} = sprintf("%d", $rdev / $rdevtomajor) . $MAJORMINORSEPARATOR . ($rdev % $rdevtomajor);
#		$ptr->{display} = $entry . $filetypeflags{$ptr->{type}};
#	} else {
#		$ptr->{display} = $entry . $filetypeflags{$ptr->{type}};
#	}
#	$ptr->{name_too_long} = length($ptr->{display}) > $maxfilenamelength-1
#							? $NAMETOOLONGCHAR : ' ';
#	$total_nr_of{ $ptr->{type} }++; # this is wrong! e.g. after cOmmand
#	return $ptr;
#}
#
sub filetypeflag {
	my $file = shift;
	if ($file->{type} eq '-' and $file->{mode} =~ /.[xst]/) {
		return $filetypeflags{'x'};
	} else {
		return $filetypeflags{$file->{type}};
	}
}

#sub readcontents { # (current)directory
#	my (@contents, $entry);
#	my @allentries = ();
#	my @white_entries = ();
#	%usercache = %groupcache = ();
##	show_headings($swap_mode, $HEADING_DISKINFO);
#	if (opendir CURRENT, "$_[0]") {
#		@allentries = readdir CURRENT;
#		closedir CURRENT;
#		if ($white_cmd) {
#			@white_entries = `$white_cmd $_[0]`;
#		}
#	} else {
#		$scr->at(0,0)->clreol();
#		display_error("Cannot read . : $!");
#	}
#	# next lines also correct for directories with no entries at all
#	# (this is sometimes the case on NTFS filesystems: why?)
#	if ($#allentries < 0) {
#		@allentries = ('.', '..');
#	}
##	local $SIG{INT} = sub { return @contents };
#	if ($#allentries > $SLOWENTRIES) {
#		# don't use display_error here because that would just cost more time
#		$scr->at(0,0)->clreol()->putcolored($framecolors{$color_mode}{message}, 'Please Wait');
#	}
#	foreach $entry (@allentries) {
#		# have the mark cleared on first stat with ' '
#		push @contents, stat_entry($entry, ' ');
#	}
#	foreach $entry (@white_entries) {
#		$entry = stat_entry($entry, ' ');
#		$entry->{type} = 'w';
#		substr($entry->{mode}, 0, 1) = 'w';
#		push @contents, $entry;
#	}
#	show_menu();
#	handlemorercsopen() if $autorcs;
#	show_headings($swap_mode, $HEADING_DISKINFO);
#	return @contents;
#}
#
#sub printdircontents { # @contents
#	foreach my $i ($baseindex .. $baseindex+$screenheight) {
#		unless ($i > $#_) {
#			$scr->at($i+$BASELINE-$baseindex,$filerecordcol)
#				->puts(fileline($_[$i], @layoutfields));
#			applycolor($i+$BASELINE-$baseindex, $FILENAME_SHORT, %{$_[$i]});
#		} else {
#			$scr->at($i+$BASELINE-$baseindex,$filerecordcol)
#				->puts(' 'x($screenwidth - $infolength));
#		}
#	}
#}
#
#sub filterdir {
#	return grep { $dot_mode   || $_->{name} =~ /^(\.\.?|[^\.].*)$/
#		   and    $white_mode || $_->{type} ne 'w'
#	} @_;
#}
#
#sub init_dircount {
#	%selected_nr_of =
#	%total_nr_of    = ( d=>0, l=>0, '-'=>0, c=>0, b=>0,
#						D=>0, p=>0, 's'=>0, n=>0, w=>0, bytes => 0);
#}
#
#sub countcontents {
#	init_dircount();
#	foreach my $i (0..$#_) {
#		$total_nr_of   {$_[$i]{type}}++;
#		$selected_nr_of{$_[$i]{type}}++ if ($_[$i]{selected} eq '*');
#	}
#}
#
#sub init_filesystem_info {
#	my (@dflist, %tdisk);
#	chop (@dflist = (`$DFCMD .`, ''));
#	shift @dflist;
#	$dflist[0] .= $dflist[1]; # in case filesystem info wraps onto next line
#	@tdisk{qw/device total used avail/} = split (/\s+/, $dflist[0]);
#	$tdisk{avail} = $tdisk{total} - $tdisk{used} if $tdisk{avail} =~ /%/;
#	@tdisk{qw/mountpoint/} = $dflist[0] =~ /(\S*)$/;
#	return %tdisk;
#}
#
sub find_best_find_match {
	my ($seek, $rec) = @_;
	my ($first, $second, $char);
	if ($rec == 0) {
		return -$baseindex;
	}
	$first  = $showncontents[$rec-1]{name};
	$second = $showncontents[$rec  ]{name};
	for ($char = length($seek); $char > 0; $char--) {
		if (substr($first,  0, $char) eq substr($seek, 0, $char)) {
			return $rec -1 - $baseindex;
		}
		if (substr($second, 0, $char) eq substr($seek, 0, $char)) {
			return $currentline = $rec - $baseindex;
		}
	}
	return $rec - $baseindex;
}

sub position_cursor_find_incremental {
	my $criterion;
	$currentline = 0;
	if ($sort_mode eq 'n') {
		$criterion = sub {
			return ($position_at le substr($_[0], 0, length($position_at)));
		};
	} else {
		# $sort_mode eq 'N'
		$criterion = sub {
			return ($position_at ge substr($_[0], 0, length($position_at)));
		};
	}
	ANYENTRYFIND: {
		for (0..$#showncontents) {
			if ($criterion->($showncontents[$_]{name})) {
				$currentline = find_best_find_match($position_at, $_);
				last ANYENTRYFIND;
			}
		}
		$currentline = $#showncontents - $baseindex;
	}
	$position_at = '';
	return validate_position(); # refresh flag
}

#sub position_cursor {
#	$currentline = 0;
#	$baseindex   = 0 if $position_at eq '..'; # descending into this dir
#	ANYENTRY: {
#		for (0..$#showncontents) {
#			if ($position_at eq $showncontents[$_]{name}) {
#				$currentline = $_ - $baseindex;
#				last ANYENTRY;
#			}
#		}
#		$baseindex = 0;
#	}
#	$position_at = '';
#	return validate_position(); # refresh flag
#}
#
#sub set_argv0 {
#	# this may be helpful for sysadmins trying to unmount a filesystem
#	$0 = 'pfm [on ' . ( $disk{device} eq 'none' ? $disk{mountpoint}
#												: $disk{device} ) . ']';
#}
#
#sub recalc_ptr {
#	$position_at = '.';
#	return position_cursor(); # refresh flag
#}
#
#sub showdiskinfo {
#	my $spaces = ' ' x $infolength;
#	# gap is not filled in yet
#	my $gap = ' ' x (max($infocol-length($currentformatline)-$filerecordcol,
#						 $filerecordcol-$infolength));
#	disk_info(%disk);
#	$scr->at($DIRINFOLINE-2, $infocol)->puts($spaces);
#	dir_info(%total_nr_of);
#	$scr->at($MARKINFOLINE-2, $infocol)->puts($spaces);
#	mark_info(%selected_nr_of);
#	$scr->at($USERINFOLINE-1, $infocol)->puts($spaces);
#	user_info();
#	clock_info();
#	foreach ($DATEINFOLINE+2 .. $BASELINE+$screenheight) {
#		$scr->at($_, $infocol)->puts($spaces);
#	}
#}
#
##########################################################################
# directory browsing main routine
#
# this sub is the heart of pfm. it has the following structure:
#
# until quit {
#		refresh everything flagged for refreshing;
#		wait for keypress-, mousedown- or resize-event;
#		handle the request;
# }
#
# when a key command handling sub exits, browse() uses its return value
# to decide which elements should be redrawn on-screen, and what else
# should be refreshed.
# the following are valid return values:
#
# $R_NOP    (=0) # no action was required, wait for new key
# $R_STRIDE		 # refresh %currentfile, validate cursor position (always done)
# $R_MENU		 # reprint the menu (header)
# $R_PATHINFO	 # reprint the pathinfo
# $R_HEADINGS	 # reprint the headings
# $R_FOOTER		 # reprint the footer
# $R_FRAME		 # combination of R_MENU, R_PATHINFO, R_HEADINGS and R_FOOTER
# $R_DISKINFO	 # reprint the disk- and directory info column
# $R_DIRLIST	 # redisplay directory listing
# $R_DIRFILTER	 # decide which entries to display (init @showncontents)
# $R_SCREEN		 # combination of R_DIRFILTER, R_DIRLIST, R_DISKINFO and R_FRAME
# $R_CLEAR		 # clear the screen
# $R_CLRSCR		 # combination of R_CLEAR and R_SCREEN
# $R_DIRSORT	 # resort @dircontents
# $R_DIRCONTENTS # reread directory contents
# $R_NEWDIR		 # re-init directory-specific vars
# $R_CHDIR		 # combination of R_NEWDIR, R_DIRCONTENTS, R_DIRSORT, R_SCREEN
# $R_INIT_SWAP	 # after reading the directory, we should be swapped immediately
# $R_QUIT		 # exit from program
#
#sub browse {
#	my $wantrefresh = shift;
#	my $key;
#	STRIDE: until ($wantrefresh & $R_QUIT) {
#		if ($wantrefresh &   $R_NEWDIR) {
#			$wantrefresh &= ~$R_NEWDIR;
#			# it's dangerous to leave multiple_mode on when changing directories
#			# 'autoexitmultiple' is only for leaving it on between commands
#			$multiple_mode = 0;
#			$currentdir    = getcwd() if $path_mode eq 'phys';
#			%disk          = init_filesystem_info();
#			#set_argv0();
#			# this test is nested so that it does not get executed every time
#			if ($wantrefresh &   $R_INIT_SWAP) {
#				$wantrefresh &= ~$R_INIT_SWAP;
#				# if $swapstartdir is set, we will make a first pass through
#				# this then{} construct: it reads the main dircontents
#				# and calls handleswap(), which detects $swapstartdir and
#				# swaps forward, and subsequently erases $swapstartdir.
#				# if 'persistentswap' is on, R_INIT_SWAP will be set again,
#				# which will take us on a second pass through this
#				# then{} construct, and we will be swapped back.
#				# the swapback does not set R_INIT_SWAP again.
#				init_dircount();
#				# first pass, read main dir.
#				# second pass, read swap dir.
#				@dircontents  = sort as_requested readcontents($currentdir);
#				%currentfile  = %{$dircontents[$currentline+$baseindex]};
#				$wantrefresh |= handleswap();
#				unless ($swap_mode) {
#					# on second pass, flag that the main dir
#					# does not need reading any more
#					$wantrefresh &= ~($R_DIRCONTENTS | $R_DIRSORT);
#				}
#				redo STRIDE;
#			}
#		}
#		# draw frame as soon as possible: this looks better on slower terminals
#		if ($wantrefresh &   $R_CLEAR) {
#			$wantrefresh &= ~$R_CLEAR;
#			$scr->clrscr();
#		}
#		if ($wantrefresh & $R_FRAME) {
#			$wantrefresh &= ~($R_HEADINGS | $R_MENU | $R_FOOTER);
#			draw_frame();
#		}
#		# now in order of severity
#		if ($wantrefresh &   $R_DIRCONTENTS) {
#			$wantrefresh &= ~$R_DIRCONTENTS;
#			init_dircount();
#			$position_at  = $showncontents[$currentline+$baseindex]{name} unless length($position_at);
#			@dircontents  = readcontents($currentdir);
#		}
#		if ($wantrefresh &   $R_DIRSORT) {
#			$wantrefresh &= ~$R_DIRSORT;
#			$position_at  = $showncontents[$currentline+$baseindex]{name} unless length($position_at);
#			@dircontents  = sort as_requested @dircontents;
#		}
#		if ($wantrefresh &   $R_DIRFILTER) {
#			$wantrefresh &= ~$R_DIRFILTER;
#			@showncontents = filterdir(@dircontents);
#		}
#		if ($wantrefresh &   $R_STRIDE) {
#			$wantrefresh &= ~$R_STRIDE;
#			position_cursor() if $position_at ne '';
#			recalc_ptr() unless defined $showncontents[$currentline+$baseindex];
#			%currentfile = %{$showncontents[$currentline+$baseindex]};
#		}
#		if ($wantrefresh &   $R_DIRLIST) {
#			$wantrefresh &= ~$R_DIRLIST;
#			$_listing->show();
#		}
#		if ($wantrefresh &   $R_DISKINFO) {
#			$wantrefresh &= ~$R_DISKINFO;
#			showdiskinfo();
#		}
#		if ($wantrefresh &   $R_MENU) {
#			$wantrefresh &= ~$R_MENU;
#			show_menu();
#		}
#		if ($wantrefresh &   $R_PATHINFO) {
#			$wantrefresh &= ~$R_PATHINFO;
#			path_info();
#		}
#		if ($wantrefresh &   $R_HEADINGS) {
#			$wantrefresh &= ~$R_HEADINGS;
#			show_headings($swap_mode, $HEADING_DISKINFO);
#		}
#		if ($wantrefresh &   $R_FOOTER) {
#			$wantrefresh &= ~$R_FOOTER;
#			show_footer();
#		}
#		# normally, the current cursor position must be validated every pass
#		$wantrefresh |= $R_STRIDE;
#		# don't send mouse escapes to the terminal if not necessary
#		highlightline($HIGHLIGHT_ON);
#		mouseenable($MOUSE_ON) if $mouse_mode && $mouseturnoff;
#		MAIN_WAIT_LOOP: until (length($scr->{IN}) || $wasresized || $scr->key_pressed(1)) {
#			clock_info();
#			handlepipes();
#			$scr->at($currentline+$BASELINE, $cursorcol);
#		}
#		if ($wasresized) {
#			$wantrefresh |= handleresize();
#		# the next line contains an assignment on purpose
#		} elsif (length($scr->{IN}) || $scr->key_pressed() and $key = $scr->getch()) {
#			highlightline($HIGHLIGHT_OFF);
#			mouseenable($MOUSE_OFF) if $mouseturnoff;
#			KEY: for ($key) {
#				# order is determined by (supposed) frequency of use
#				/^(?:ku|kd|pgup|pgdn|[-+jk\cF\cB\cD\cU]|home|end)$/io
#								and $wantrefresh |= handlemove($_),		 last KEY;
#				/^(?:kr|kl|[h\e\cH])$/io
#								and $wantrefresh |= handleentry($_),	 last KEY;
#				/^[\cE\cY]$/o	and $wantrefresh |= handlescroll($_),	 last KEY;
#				/^l$/o			and $wantrefresh |= handlekeyell($_),	 last KEY;
#				/^ $/o			and $wantrefresh |= handleadvance($_),	 last KEY;
#				/^k5$/o			and $wantrefresh |= handlerefresh(),	 last KEY;
#				/^[cr]$/io		and $wantrefresh |= handlecopyrename($_),last KEY;
#				/^[yo]$/io		and $wantrefresh |= handlecommand($_),	 last KEY;
#				/^e$/io			and $wantrefresh |= handleedit(),		 last KEY;
#				/^d(el)?$/io	and $wantrefresh |= handledelete(),		 last KEY;
#				/^[ix]$/io		and $wantrefresh |= handleinclude($_),	 last KEY;
#				/^\r$/io		and $wantrefresh |= handleenter(),		 last KEY;
#				/^s$/io			and $wantrefresh |= handleshow(),		 last KEY;
#				/^kmous$/o		and $wantrefresh |= handlemousedown(),	 last KEY;
#				/^k7$/o			and $wantrefresh |= handleswap(),		 last KEY;
#				/^k10$/o		and $wantrefresh |= handlemultiple(),	 last KEY;
#				/^m$/io			and $wantrefresh |= handlemore(),		 last KEY;
#				/^p$/io			and $wantrefresh |= handleprint(),		 last KEY;
#				/^L$/o			and $wantrefresh |= handlesymlink(),	 last KEY;
#				/^n$/io			and $wantrefresh |= handlename($_),		 last KEY;
#				/^k8$/o			and $wantrefresh |= handleselect(),		 last KEY;
#				/^k11$/o		and $wantrefresh |= handlerestat(),		 last KEY;
#				/^[\/f]$/io		and $wantrefresh |= handlefind(),		 last KEY;
#				/^[<>]$/io		and $wantrefresh |= handlepan($_, 0),	 last KEY;
#				/^k3|\cL|\cR/o	and $wantrefresh |= handlefit(),		 last KEY;
#				/^t$/io			and $wantrefresh |= handletime(),		 last KEY;
#				/^a$/io			and $wantrefresh |= handlechmod(),		 last KEY;
#				/^q$/io			and $wantrefresh |= handlequit($_),		 last KEY;
#				/^k6$/o			and $wantrefresh |= handlesort(),		 last KEY;
#				/^(?:k1|\?)$/o	and $wantrefresh |= handlehelp(),		 last KEY;
#				/^k2$/o			and $wantrefresh |= handlecdold(),		 last KEY;
#				/^\.$/o			and $wantrefresh |= handledot(),		 last KEY;
#				/^k9$/o			and $wantrefresh |= handlelayouts(),	 last KEY;
#				/^k4$/o			and $wantrefresh |= handlecolor(),		 last KEY;
#				/^\@$/o			and $wantrefresh |= handleperlcommand(), last KEY;
#				/^u$/io			and $wantrefresh |= handlechown(),		 last KEY;
#				/^v$/io			and $wantrefresh |= handlercs(),		 last KEY;
#				/^z$/io			and $wantrefresh |= handlesize(),		 last KEY;
#				/^g$/io			and $wantrefresh |= handletarget(),		 last KEY;
#				/^k12$/o		and $wantrefresh |= handlemouse(),		 last KEY;
#				/^=$/o			and $wantrefresh |= handleident(),		 last KEY;
#				/^\*$/o			and $wantrefresh |= handleradix(),		 last KEY;
#				/^!$/o			and $wantrefresh |= handleclobber(),	 last KEY;
#				/^"$/o			and $wantrefresh |= handlepathmode(),	 last KEY;
#				/^w$/io			and $wantrefresh |= handleunwo(),		 last KEY;
#				/^%$/io			and $wantrefresh |= handlewhiteout(),	 last KEY;
#				# invalid keypress: cursor position needs no checking
#				$wantrefresh &= ~$R_STRIDE;
#			} # switch KEY
#		} # if key_pressed
#	} # until QUIT
#}
#
##########################################################################
# main() is not of type void
#
#globalinit();
#browse($R_CHDIR | ($R_INIT_SWAP * defined $swapstartdir));
#goodbye();
#exit 0;
#
# vim:     set tabstop=4 shiftwidth=4 noexpandtab:
# vim>600: set foldmethod=indent nofoldenable:
