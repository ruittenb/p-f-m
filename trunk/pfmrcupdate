#!/usr/bin/env perl
############################################################################
#
# Name:         pfmrcupdate
# Version:      2.05.6
# Author:       Rene Uittenbogaard
# Date:         2010-05-28
# Usage:        pfmrcupdate
# Description:  Update an existing .pfmrc so that it can be used with
#               newer versions of pfm.
#
#		This is a get-me-going-fast solution. You may be better
#		off by having pfm generate a new .pfmrc for you and
#		comparing it to your own version.
#

############################################################################
# version

# macros for *roff
our $ROFFVERSION = <<'=cut';

=pod

=for roff
.ds Yr 2010
.ds Vw @(#) pfmrcupdate 2.05.6
.de Vp
This manual pertains to \f(CWpfmrcupdate\fP version \\$3.
..
.hy 0 \" hyphenation off

=cut

############################################################################
# declarations

use POSIX qw(mktime strftime);
use strict;
use locale;

my $amphibian;

############################################################################
# helper functions

sub min {
	return +(sort { $a <=> $b } @_)[0];
}

sub max {
	return +(reverse sort { $a <=> $b } @_)[0];
}

sub backup_pfmrc {
	my ($pfmrc) = @_;
	my $now     = strftime('%Y%m%dT%H%M%S', localtime);
	if (system "cp \Q$pfmrc\E \Q$pfmrc.$now\E") {
		die "Could not backup $pfmrc to $pfmrc.$now, aborting";
	}
	print "Backing up $pfmrc to\n$pfmrc.$now (ok)\n";
}

sub write_pfmrc {
	my ($pfmrc, @pfmrc) = @_;
	open FILE, ">$pfmrc" or die "Cannot open $pfmrc for writing: $!, aborting";
	print FILE @pfmrc;
	close FILE;
	print "Successfully wrote $pfmrc\n";
}

sub findfile {
	my ($file) = @_;
	my $dir;
	foreach $dir ('.', split /:/, $ENV{PATH}) {
		return "$dir/$file" if -f "$dir/$file";
	}
	die "Cannot find '$file' anywhere in \$PATH ($ENV{PATH}), aborting";
}

sub fileslurp {
	my ($filename) = @_;
	open FILE, $filename or die "Cannot open $filename: $!, aborting";
	my @lines = <FILE>;
	close FILE;
	return @lines;
}

sub get_locale {
	open PIPE, 'locale|';
	my @lines = grep /^LC_TIME/, <PIPE>;
	close PIPE;
	chomp @lines;
	return $lines[0];
}

sub get_pfm_version {
	my ($seek) = @_;
	my ($pfmfile, $version);
	$pfmfile = findfile($seek);
	$version = (grep /\@\(#\)/, fileslurp($pfmfile))[0];
	$version =~ s/.*?\@\(#\)\D+(?:\d{4}-\d{2}-\d{2}\s*)?v?([[:alnum:].]+).*/$1/;
	chomp $version;
	return $version;
}

sub get_pfmrc {
	my ($pfmrc) = @_;
	return fileslurp($pfmrc);
}

sub get_pfmrc_version {
	my $version = (grep /Version\D+([[:alnum:].]+)/, @_)[0];
	$version =~ s/.*?Version\D+([[:alnum:].]+).*/$1/;
	chomp $version;
	return $version;
}

sub get_pfmrc_timefieldlen {
	my @layouts = grep /^[^#].*ffffffffffffff/, @_;
	my $minlength = 80;
	my ($mlength, $clength, $alength, $layout);
	foreach (@layouts) {
		$mlength = tr/m// || 80;
		$clength = tr/c// || 80;
		$alength = tr/a// || 80;
		$minlength = min($minlength, $mlength, $clength, $alength);
	}
	return $minlength;
}

sub get_pfmrc_timefieldformat {
	my $timefieldformat = (grep /^timestampformat:/, @_)[0];
	$timefieldformat =~ s/^[^:]*?:(.*)$/$1/;
	chomp $timefieldformat;
	return $timefieldformat;
}

############################################################################
# check functions

sub check_date_locale {
	my ($pfmrc, @pfmrc) = @_;
	my $timefieldlen    = get_pfmrc_timefieldlen(@pfmrc);
	my $timefieldformat = get_pfmrc_timefieldformat(@pfmrc);
	my $locale          = get_locale();
	#
	my ($mon, $timestr, $maxtimelength);
	foreach $mon (0..11) {
		# (sec, min, hour, mday, mon, year, wday = 0, yday = 0, isdst = -1)
		$timestr = strftime($timefieldformat, (0, 30, 10, 12, $mon, 95));
		$maxtimelength = max(length($timestr), $maxtimelength);
	}
	if ($maxtimelength > $timefieldlen) {
		print <<_LOCALE_WARNING_

Warning: Your date/time locale is set to $locale. In this locale,
the configured timestampformat of '$timefieldformat' in your .pfmrc may
require up to $maxtimelength characters.

Some of the layouts in your .pfmrc only allow for $timefieldlen characters.

Please verify that your file timestamps don't look truncated, otherwise
please change the 'columnlayouts' or 'timestampformat' option manually.

_LOCALE_WARNING_
	} else {
		print "Checking timestampformat vs. locale (ok)\n";
	}
}

sub check_versions {
	my ($rcversion, $binversion) = @_;
	unless ($rcversion) {
		print <<_PFMRC_VERSION_WARNING_;

Warning: The version number of your config file could not be
determined. (Are you using the \$PFMRC variable?)
Please have pfm create a new config file so that you will not
miss any configuration file updates.

_PFMRC_VERSION_WARNING_
		return 0;
	}
	unless ($binversion) {
		print <<_PFM_VERSION_WARNING_;

Warning: The version number of the pfm executable could not be
determined. Please make sure that pfm is installed in a directory
in your \$PATH.

_PFM_VERSION_WARNING_
		return 0;
	}
	return 1;
}

############################################################################
# update functions

sub update_to_184 {
	my ($lines) = @_;
	# this updates (Y)our commands for version 1.84
	print "Updating to 1.84...\n";
	s/^(\s*)([[:upper:]])(\s*):(.*)$/$1your[\l$2]$3:$4/ foreach @$lines;
	s/^(\s*)([[:lower:]])(\s*):(.*)$/$1your[\u$2]$3:$4/ foreach @$lines;
}

sub update_to_188 {
	my ($lines) = @_;
	# this replaces the pre-1.88 colors by 1.88-style colors.
	print "Updating to 1.88...\n";
	my %attributes = reverse (     'black'      => 30,  'on_black'   => 40,
		'reset'      => '00',  'red'        => 31,  'on_red'     => 41,
		'bold'       => '01',  'green'      => 32,  'on_green'   => 42,
		'underline'  => '04',  'yellow'     => 33,  'on_yellow'  => 43,
		                       'blue'       => 34,  'on_blue'    => 44,
		'blink'      => '05',  'magenta'    => 35,  'on_magenta' => 45,
		'inverse'    => '07',  'cyan'       => 36,  'on_cyan'    => 46,
		'concealed'  => '08',  'white'      => 37,  'on_white'   => 47,
	);
	foreach (@$lines) {
		!/^#/ && /[=;]/ && s/\b([034]\d)\b/$attributes{$1}/g && tr/;/ /;
	}
}

sub update_to_189 {
	my ($lines) = @_;
	# this updates quoting in commands for version 1.89
	print "Updating to 1.89...\n";
	my $warned = 0;
	foreach (@$lines) {
		s/(['"])(\\[1-6])\1/$2/g;
		s/(printcmd:.*)/$1 \\2/g;
		/cp.*date.*touch.*date/ && s/"(
		[^"()]*
		\$\(
		[^")]*
		(?:"[^"]*")*
		\)
		)"/$1/gx;
		if (/\$\(.*\)/ and !$warned) {
			print "\nWarning: Quoting \$(..) constructs can be tricky.\n";
			print "Please double-check your .pfmrc. I'm imperfect.\n";
			$warned++;
		}
	}
	push @$lines, <<'_end_update_to_189_';

# convert $LS_COLORS into an additional colorset?
importlscolors:yes
	
_end_update_to_189_
}

sub update_to_1901 {
	my ($lines) = @_;
	# added 'viewer' option
	# added dir/framecolors[*] option
	# added '\[epv]' escapes
	foreach (@$lines) {
		if (/^(your|launch)/) {
			s/(\$PAGER|\bmore|\bless)\b/\\p/g;
			s/\$VIEWER\b/\\v/g;
			s/\$EDITOR\b/\\e/g;
		}
	}
	push @$lines, <<'_end_update_to_1901_';

## preferred image editor/viewer (don't specify \2 here)
#viewer:eog
viewer:xv

## The special set 'framecolors[*]' will be used for every 'dircolors[x]'
## for which there is no corresponding 'framecolors[x]' (like ls_colors)
framecolors[*]:\
title=reverse:swap=reverse:footer=reverse:highlight=bold:

## The special set 'dircolors[*]' will be used for every 'framecolors[x]'
## for which there is no corresponding 'dircolors[x]'
dircolors[*]:\
di=bold:ln=underscore:

_end_update_to_1901_
}

sub update_to_1904 {
	my ($lines) = @_;
	# changed config option 'viewbase' to 'defaultnumbase'
	print "Updating to 1.90.4...\n";
	foreach (@$lines) {
		s/\bviewbase\b/defaultnumbase/g;
	}
}

sub update_to_1913 {
	my ($lines) = @_;
	# this removes 'timeformat' for version 1.91.3
	print "Updating to 1.91.3...\n";
	my $i;
	for ($i = $#$lines; $i > 0; $i--) {
		if (${$lines}[$i] =~ /^#*\s*(timeformat:|format for entering time:)/
		or ${$lines}[$i] =~ /^#*\s*touch MMDDhhmm\S* or pfm .*MMDDhhmm/)
		{
			splice(@{$lines}, $i, 1);
		}
	}
}

sub update_to_1914 {
	my ($lines) = @_;
	# changed config option 'defaultnumbase' to 'defaultradix'
	print "Updating to 1.91.4...\n";
	foreach (@$lines) {
		s/\bdefaultnumbase\b/defaultradix/g;
	}
}

sub update_to_1915 {
	my ($lines) = @_;
	# added 'clockdateformat' and 'clocktimeformat' options
	print "Updating to 1.91.5...\n";
	push @$lines, <<_end_update_to_1915_;

## clock date/time format; see strftime(3).
## %x and %X provide properly localized time and date.
## the defaults are "%Y %b %d" and "%H:%M:%S"
## the diskinfo field (f) in the layouts below must be wide enough for this.
clockdateformat:%Y %b %d
#clocktimeformat:%H:%M:%S
#clockdateformat:%x
clocktimeformat:%X

_end_update_to_1915_
}

sub update_to_1917 {
	my ($lines) = @_;
	# this adds a diskinfo column (f-column) to pre-1.91.7 config files
	print "Updating to 1.91.7...\n";
	foreach (@$lines) {
		s/^([^#].*nnnn.*)(:\\?)$/$1 ffffffffffffff$2/;
		s{ layouts must not be wider than this! }
		 {-------------- file info -------------};
	}
}

sub update_to_1920 {
	my ($lines) = @_;
	# changes important comments.
	print "Updating to 1.92.0...\n";
	my $i;
	foreach (@$lines) {
		s{magic\[Sun/NeXT audio data\](\s*:\s*)audio/basic}
		 {magic\[Sun.NeXT audio data\]$1audio/basic};
		s{(diskinfo field) is as yet only supported as the last column.}
		 {$1 *must* be the _first_ or _last_ field on the line.};
		s{## launch commands.*not implemented.*}
		 {## launch commands};
	}
	my @new = (
"## the option itself may not contain whitespace or colons,\n",
"## except in a classifier enclosed in [] that immediately follows it.\n",
'## in other words: /^\s*([^[:\s]+(?:\[[^]]+\])?)\s*:\s*(.*)$/'."\n",
);
	for ($i = $#$lines; $i > 0; $i--) {
		if (${$lines}[$i] =~ /## in other words:/) {
			splice @$lines, $i, 1, @new;
		}
	}
}

sub update_to_1921 {
	my ($lines) = @_;
	# changed option 'clobber' to 'defaultclobber'
	print "Updating to 1.92.1...\n";
	foreach (@$lines) {
		s/^(#*\s*)\bclobber\b/$1defaultclobber/g;
	}
}

sub update_to_1923 {
	my ($lines) = @_;
	# added 'waitlaunchexec', but this was deprecated later.
	# no need to add it here because it was never implemented.
}

sub update_to_1926 {
	my ($lines) = @_;
	# inverted meaning of 'defaultdotmode' and 'defaultwhitemode'
	print "Updating to 1.92.6...\n";
	foreach (@$lines) {
		s/\bdotmode:\s*yes\b/defaultdotmode: no/g;
		s/\bdotmode:\s*no\b/defaultdotmode: yes/g;
		s/\bwhitemode:\s*yes\b/defaultwhitemode: no/g;
		s/\bwhitemode:\s*no\b/defaultwhitemode: yes/g;
	}
}

sub update_to_1931 {
	my ($lines) = @_;
	# added 'escapechar'; changed default escape char.
	print "Updating to 1.93.1...\n";
	foreach (@$lines) {
		s/\\([1-7epv])/=$1/g;
		s/\\\\/==/g;
	}
	push @$lines, <<'_end_update_to_1931_';

extension[*.dvi] : application/x-dvi
extension[*.jar] : application/zip
extension[*.man] : application/x-groff-man
extension[*.mm]  : application/x-groff-mm
extension[*.pdb] : chemical/x-pdb
magic[TeX DVI file] : application/x-dvi

## the character that pfm recognizes as special abbreviation character
## (default =)
## previous versions used \ (note that this leads to confusing results)
#escapechar:=
#escapechar:\

_end_update_to_1931_
}

sub update_to_1938 {
	my ($lines) = @_;
	# added 'altscreenmode'
	print "Updating to 1.93.8...\n";
	push @$lines, <<'_end_update_to_1938_';

## use xterm alternate screen buffer (yes,no,xterm) (default: only in xterm)
altscreenmode:xterm

_end_update_to_1938_
}

sub update_to_1942 {
	my ($lines) = @_;
	# subversion support; 'rcscmd', 'autorcs'
	print "Updating to 1.94.2...\n";
	push @$lines, <<_end_update_to_1942_;

## request rcs status automatically?
autorcs:yes

## command to use for requesting the file status in your rcs system.
rcscmd:svn status

_end_update_to_1942_
}

sub update_to_1948 {
	my ($lines) = @_;
	# added openoffice document extensions to default .pfmrc
	print "Updating to 1.94.8...\n";
	push @$lines, <<_end_update_to_1948_;

extension[*.odp]  : application/x-openoffice
extension[*.ods]  : application/x-openoffice
extension[*.odt]  : application/x-openoffice
launch[application/x-openoffice]  : ooffice =2 &

_end_update_to_1948_
}

sub update_to_1951 {
	my ($lines) = @_;
	# added 'remove_marks_ok' option
	print "Updating to 1.95.1...\n";
	push @$lines, <<_end_update_to_1951_;

## is it always "OK to remove marks?" without confirmation?
remove_marks_ok:no

_end_update_to_1951_
}

sub update_to_1952 {
	my ($lines) = @_;
	# added 'checkforupdates' option (was deprecated later).
	print "Updating to 1.95.2...\n";
	push @$lines, <<_end_update_to_1952_;

## automatically check for updates on exit (default: no) 
checkforupdates:no 

_end_update_to_1952_
}

sub update_to_200 {
	my ($lines) = @_;
	# this updates the framecolors for version 2.00
	print "Updating to 2.00...\n";
	if ($amphibian) {
		foreach (@$lines) {
			s/(^|:)(header=)([^:]*)/$1$2$3:menu=$3/;
			s/(^|:)(title=)([^:]*)/$1$2$3:headings=$3/;
		}
	} else {
		foreach (@$lines) {
			s/(^|:)header=/${1}menu=/;
			s/(^|:)title=/${1}headings=/;
		}
	}
}

sub update_to_2017 {
	my ($lines) = @_;
	# this removes 'checkforupdates' for version 2.01.7
	print "Updating to 2.01.7...\n";
	my $i;
	for ($i = $#$lines; $i > 0; $i--) {
		if (${$lines}[$i] =~ /^#*\s*checkforupdates:/
		or  ${$lines}[$i] =~ /^#+\s*automatically check for updates on exit/)
		{
			splice(@$lines, $i, 1);
		}
	}
}

sub update_to_2037 {
	my ($lines) = @_;
	# this removes 'waitlaunchexec' for version 2.03.7
	print "Updating to 2.03.7...\n";
	my $i;
	for ($i = $#$lines; $i > 0; $i--) {
		if (${$lines}[$i] =~ /^#*\s*waitlaunchexec:/
		or  ${$lines}[$i] =~ /^#+\s*wait for launched executables to finish/)
		{
			splice(@$lines, $i, 1);
		}
	}
}

sub update_to_2044 {
	my ($lines) = @_;
	# added 'copyoptions'
	print "Updating to 2.04.4...\n";
	push @$lines, <<_end_update_to_2044_;

## commandline options to add to the cp(1) command, in the first place for
## changing the 'follow symlinks' behavior.
#copyoptions:-P

_end_update_to_2044_
}

sub update_to_2053 {
	my ($lines) = @_;
	# added extra MIME types
	print "Updating to 2.05.3...\n";
	push @$lines, <<_end_update_to_2053_;

extension[*.3pm]  : application/x-nroff-man
extension[*.js]   : application/javascript
extension[*.m3u]  : text/x-m3u-playlist
extension[*.sql]  : application/x-sql

launch[application/javascript]    : =e =2
launch[application/x-sql]         : =e =2
launch[audio/mpeg]                : vlc =2 >/dev/null 2>&1
launch[text/x-m3u-playlist]       : vlc =2 >/dev/null 2>&1

_end_update_to_2053_
}

sub update_version {
	my ($to, $lines) = @_;
	# this updates the version field for any version
	print "Updating to $to...\n";
	foreach (@$lines) {
		s/^(#.*?Version\D+)[[:alnum:].]+/$1$to/;
	}
}

sub update_pfmrc {
	my ($from, $to, $lines) = (@_);
	update_to_184 ($lines) if $from lt '1.84'   and '1.84'   le $to;
	update_to_188 ($lines) if $from lt '1.88'   and '1.88'   le $to;
	update_to_189 ($lines) if $from lt '1.89'   and '1.89'   le $to;
	update_to_1901($lines) if $from lt '1.90.1' and '1.90.1' le $to;
	update_to_1904($lines) if $from lt '1.90.4' and '1.90.4' le $to;
	update_to_1913($lines) if $from lt '1.91.3' and '1.91.3' le $to;
	update_to_1914($lines) if $from lt '1.91.4' and '1.91.4' le $to;
	update_to_1915($lines) if $from lt '1.91.5' and '1.91.5' le $to;
	update_to_1917($lines) if $from lt '1.91.7' and '1.91.7' le $to;
	update_to_1920($lines) if $from lt '1.92.0' and '1.92.0' le $to;
	update_to_1921($lines) if $from lt '1.92.1' and '1.92.1' le $to;
	update_to_1923($lines) if $from lt '1.92.3' and '1.92.3' le $to;
	update_to_1926($lines) if $from lt '1.92.6' and '1.92.6' le $to;
	update_to_1931($lines) if $from lt '1.93.1' and '1.93.1' le $to;
	update_to_1938($lines) if $from lt '1.93.8' and '1.93.8' le $to;
	update_to_1942($lines) if $from lt '1.94.2' and '1.94.2' le $to;
	update_to_1948($lines) if $from lt '1.94.8' and '1.94.8' le $to;
	update_to_1951($lines) if $from lt '1.95.1' and '1.95.1' le $to;
	update_to_1952($lines) if $from lt '1.95.2' and '1.95.2' le $to;
	update_to_200 ($lines) if $from lt '2.00'   and '2.00'   le $to;
	update_to_2017($lines) if $from lt '2.01.7' and '2.01.7' le $to;
	update_to_2037($lines) if $from lt '2.03.7' and '2.03.7' le $to;
	update_to_2044($lines) if $from lt '2.04.4' and '2.04.4' le $to;
	update_to_2053($lines) if $from lt '2.05.3' and '2.05.3' le $to;
	update_version($to, $lines);
}

sub main {
	my $rcfile        = $ENV{PFMRC} || "$ENV{HOME}/.pfm/.pfmrc";
	my $script        = $ENV{PFM}   || 'pfm';
	my @pfmrc         = get_pfmrc($rcfile);
	my $version_pfmrc = get_pfmrc_version(@pfmrc);
	my $version_pfm   = get_pfm_version($script);
	$amphibian        = ($_[0] =~ /^(--amphibian|-a)$/);
	#
	print "\nChecking the config file at $rcfile\n";
	die '' unless check_versions($version_pfmrc, $version_pfm);
	check_date_locale($rcfile, @pfmrc);
	print "\nYour  pfm   version is: $version_pfm\n";
	print "Your .pfmrc version is: $version_pfmrc ";
	if ($version_pfmrc ge $version_pfm) {
		print "(up to date)\n\n";
		return;
	}
	print "(needs updating)\n\n";
	backup_pfmrc($rcfile);
	update_pfmrc($version_pfmrc, $version_pfm, \@pfmrc);
	write_pfmrc($rcfile, @pfmrc);
	print "Successfully updated to version $version_pfm\n";
}

############################################################################
# main

main(@ARGV);

__END__

=pod

=head1 NAME

C<pfmrcupdate> - Update a config file for C<pfm>

=head1 SYNOPSIS

C<pfmrcupdate [ -a, --amphibian ]>

=head1 DESCRIPTION

C<pfmrcupdate> is a tool for C<pfm> (Personal File Manager) that can
update an existing F<.pfmrc> for a higher version of C<pfm>.
Your original F<.pfmrc> will be backed up as F<.pfmrc.>datestamp.

This script should be regarded as a I<get-me-going-fast> solution.
You will probably be better off by having C<pfm> generate a new F<.pfmrc>
for you and comparing it to your own version.

=head1 OPTIONS

=over

=item -a, --amphibian

Keep the config file in a format that can be used with both C<pfm> version
1 and 2.

=back

=head1 ENVIRONMENT

=over

=item B<PFM>

If your C<pfm> is not installed as C<pfm> (but instead as I<e.g.> C<pfm2>)
then you may specify its name in this variable.

=item B<PFMRC>

Specify a location of an alternate F<.pfmrc> file. If unset, the default
location F<$HOME/.pfm/.pfmrc> is used.

=item B<LC_TIME>

Date/time format according to your current locale. C<pfmrcupdate> will check
to see if your 'columnlayouts' config option can accommodate the localized
strings.  See locale(7).

=back

=head1 VERSION

=for roff
.PP \" display the 'pertains to'-macro
.Vp \*(Vw

=head1 AUTHOR and COPYRIGHT

=for roff
.PP \" display the authors
.\" the \(co character only exists in groff
.ie \n(.g .ds co \(co
.el       .ds co (c)
.ie \n(.g .ds e' \('e
.el       .ds e' e\*'
..
Copyright \*(co \*(Yr, Ren\*(e' Uittenbogaard
(ruittenb@users.sourceforge.net).
.PP

=for html
Copyright &copy; Ren&eacute; Uittenbogaard
(ruittenb&#64;users.sourceforge.net).
=head1 AUTHOR and COPYRIGHT

SEE ALSO

pfm(1), locale(7).

=cut

# vim: set tabstop=8 shiftwidth=8 noexpandtab:

